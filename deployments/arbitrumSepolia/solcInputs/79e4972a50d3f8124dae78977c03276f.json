{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\n * old one. This can help prevent common mistakes, such as transfers of ownership to\n * incorrect accounts, or to contracts that are unable to interact with the\n * permission system.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     *\n     * Setting `newOwner` to the zero address is allowed; this can be used to cancel an initiated ownership transfer.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev ERC-1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1967.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.22;\n\nimport {IBeacon} from \"../beacon/IBeacon.sol\";\nimport {IERC1967} from \"../../interfaces/IERC1967.sol\";\nimport {Address} from \"../../utils/Address.sol\";\nimport {StorageSlot} from \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This library provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967] slots.\n */\nlibrary ERC1967Utils {\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the ERC-1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit IERC1967.Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by ERC-1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the ERC-1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit IERC1967.AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the ERC-1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit IERC1967.BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn't perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.22;\n\nimport {IERC1822Proxiable} from \"../../interfaces/draft-IERC1822.sol\";\nimport {ERC1967Utils} from \"../ERC1967/ERC1967Utils.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n */\nabstract contract UUPSUpgradeable is IERC1822Proxiable {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `\"5.0.0\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC-1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC-1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC-1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC-1967 compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC-1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert Errors.FailedCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\n            // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2²⁵⁶ + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1) ≡ 1 mod p`. As a consequence, we have `a * a**(p-2) ≡ 1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) < 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) ≤ sqrt(a) < 2**e → (2**(e-1))² ≤ a < (2**e)² → 2**(2*e-2) ≤ a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) < 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\n            // This is going to be our x_0 (and ε_0)\n            xn = (3 * xn) >> 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n            //              = ((x_n² + a) / (2 * x_n))² - a\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n            //              = (x_n² - a)² / (2 * x_n)²\n            //              = ((x_n² - a) / (2 * x_n))²\n            //              ≥ 0\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\n            //         = | ε_n² / (2 * x_n) |\n            //         = ε_n² / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // ε_1 = ε_0² / | (2 * x_0) |\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n            //     ≤ 2**(e-3) / 3\n            //     ≤ 2**(e-3-log2(3))\n            //     ≤ 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n            //         ≤ 2**(2*e-2*k) / 2**e\n            //         ≤ 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\n            // ε_6 ≤ 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // If upper 8 bits of 16-bit half set, add 8 to result\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\n        // If upper 4 bits of 8-bit half set, add 4 to result\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\n\n        // Shifts value right by the current result and use it as an index into this lookup table:\n        //\n        // | x (4 bits) |  index  | table[index] = MSB position |\n        // |------------|---------|-----------------------------|\n        // |    0000    |    0    |        table[0] = 0         |\n        // |    0001    |    1    |        table[1] = 0         |\n        // |    0010    |    2    |        table[2] = 1         |\n        // |    0011    |    3    |        table[3] = 1         |\n        // |    0100    |    4    |        table[4] = 2         |\n        // |    0101    |    5    |        table[5] = 2         |\n        // |    0110    |    6    |        table[6] = 2         |\n        // |    0111    |    7    |        table[7] = 2         |\n        // |    1000    |    8    |        table[8] = 3         |\n        // |    1001    |    9    |        table[9] = 3         |\n        // |    1010    |   10    |        table[10] = 3        |\n        // |    1011    |   11    |        table[11] = 3        |\n        // |    1100    |   12    |        table[12] = 3        |\n        // |    1101    |   13    |        table[13] = 3        |\n        // |    1110    |   14    |        table[14] = 3        |\n        // |    1111    |   15    |        table[15] = 3        |\n        //\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\n        assembly (\"memory-safe\") {\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Panic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC-1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {SlotDerivation}.\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SafeCast} from \"./math/SafeCast.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    using SafeCast for *;\n\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev The string being parsed contains characters that are not in scope of the given base.\n     */\n    error StringsInvalidChar();\n\n    /**\n     * @dev The string being parsed is not a properly formatted address.\n     */\n    error StringsInvalidAddressFormat();\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly (\"memory-safe\") {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly (\"memory-safe\") {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal\n     * representation, according to EIP-55.\n     */\n    function toChecksumHexString(address addr) internal pure returns (string memory) {\n        bytes memory buffer = bytes(toHexString(addr));\n\n        // hash the hex part of buffer (skip length + 2 bytes, length 40)\n        uint256 hashValue;\n        assembly (\"memory-safe\") {\n            hashValue := shr(96, keccak256(add(buffer, 0x22), 40))\n        }\n\n        for (uint256 i = 41; i > 1; --i) {\n            // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)\n            if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {\n                // case shift by xoring with 0x20\n                buffer[i] ^= 0x20;\n            }\n            hashValue >>= 4;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input) internal pure returns (uint256) {\n        return parseUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Variant of {tryParseUint} that does not check bounds and returns (true, 0) if they are invalid.\n     */\n    function _tryParseUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        uint256 result = 0;\n        for (uint256 i = begin; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 9) return (false, 0);\n            result *= 10;\n            result += chr;\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `int256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input) internal pure returns (int256) {\n        return parseInt(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input, uint256 begin, uint256 end) internal pure returns (int256) {\n        (bool success, int256 value) = tryParseInt(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that returns false if the parsing fails because of an invalid character or if\n     * the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(string memory input) internal pure returns (bool success, int256 value) {\n        return _tryParseIntUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    uint256 private constant ABS_MIN_INT256 = 2 ** 255;\n\n    /**\n     * @dev Variant of {parseInt-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character or if the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, int256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseIntUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Variant of {tryParseInt} that does not check bounds and returns (true, 0) if they are invalid.\n     */\n    function _tryParseIntUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, int256 value) {\n        bytes memory buffer = bytes(input);\n\n        // Check presence of a negative sign.\n        bytes1 sign = begin == end ? bytes1(0) : bytes1(_unsafeReadBytesOffset(buffer, begin)); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        bool positiveSign = sign == bytes1(\"+\");\n        bool negativeSign = sign == bytes1(\"-\");\n        uint256 offset = (positiveSign || negativeSign).toUint();\n\n        (bool absSuccess, uint256 absValue) = tryParseUint(input, begin + offset, end);\n\n        if (absSuccess && absValue < ABS_MIN_INT256) {\n            return (true, negativeSign ? -int256(absValue) : int256(absValue));\n        } else if (absSuccess && negativeSign && absValue == ABS_MIN_INT256) {\n            return (true, type(int256).min);\n        } else return (false, 0);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input) internal pure returns (uint256) {\n        return parseHexUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseHexUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseHexUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string-uint256-uint256} that returns false if the parsing fails because of an\n     * invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseHexUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Variant of {tryParseHexUint} that does not check bounds and returns (true, 0) if they are invalid.\n     */\n    function _tryParseHexUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        // skip 0x prefix if present\n        bool hasPrefix = (begin < end + 1) && bytes2(_unsafeReadBytesOffset(buffer, begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 offset = hasPrefix.toUint() * 2;\n\n        uint256 result = 0;\n        for (uint256 i = begin + offset; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 15) return (false, 0);\n            result *= 16;\n            unchecked {\n                // Multiplying by 16 is equivalent to a shift of 4 bits (with additional overflow check).\n                // This guaratees that adding a value < 16 will not cause an overflow, hence the unchecked.\n                result += chr;\n            }\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as an `address`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input) internal pure returns (address) {\n        return parseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input, uint256 begin, uint256 end) internal pure returns (address) {\n        (bool success, address value) = tryParseAddress(input, begin, end);\n        if (!success) revert StringsInvalidAddressFormat();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that returns false if the parsing fails because the input is not a properly\n     * formatted address. See {parseAddress} requirements.\n     */\n    function tryParseAddress(string memory input) internal pure returns (bool success, address value) {\n        return tryParseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string-uint256-uint256} that returns false if the parsing fails because input is not a properly\n     * formatted address. See {parseAddress} requirements.\n     */\n    function tryParseAddress(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, address value) {\n        // check that input is the correct length\n        bool hasPrefix = (begin < end + 1) && bytes2(_unsafeReadBytesOffset(bytes(input), begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n\n        uint256 expectedLength = 40 + hasPrefix.toUint() * 2;\n\n        if (end - begin == expectedLength && end <= bytes(input).length) {\n            // length guarantees that this does not overflow, and value is at most type(uint160).max\n            (bool s, uint256 v) = _tryParseHexUintUncheckedBounds(input, begin, end);\n            return (s, address(uint160(v)));\n        } else {\n            return (false, address(0));\n        }\n    }\n\n    function _tryParseChr(bytes1 chr) private pure returns (uint8) {\n        uint8 value = uint8(chr);\n\n        // Try to parse `chr`:\n        // - Case 1: [0-9]\n        // - Case 2: [a-f]\n        // - Case 3: [A-F]\n        // - otherwise not supported\n        unchecked {\n            if (value > 47 && value < 58) value -= 48;\n            else if (value > 96 && value < 103) value -= 87;\n            else if (value > 64 && value < 71) value -= 55;\n            else return type(uint8).max;\n        }\n\n        return value;\n    }\n\n    /**\n     * @dev Reads a bytes32 from a bytes array without bounds checking.\n     *\n     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the\n     * assembly block as such would prevent some optimizations.\n     */\n    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\n        assembly (\"memory-safe\") {\n            value := mload(add(buffer, add(0x20, offset)))\n        }\n    }\n}\n"
    },
    "clober-dex/v2-core/interfaces/IBookManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\n\nimport {BookId} from \"../libraries/BookId.sol\";\nimport {Currency} from \"../libraries/Currency.sol\";\nimport {OrderId} from \"../libraries/OrderId.sol\";\nimport {Tick} from \"../libraries/Tick.sol\";\nimport {FeePolicy} from \"../libraries/FeePolicy.sol\";\nimport {IERC721Permit} from \"./IERC721Permit.sol\";\nimport {IHooks} from \"./IHooks.sol\";\n\n/**\n * @title IBookManager\n * @notice The interface for the BookManager contract\n */\ninterface IBookManager is IERC721Metadata, IERC721Permit {\n    error InvalidUnitSize();\n    error InvalidFeePolicy();\n    error InvalidProvider(address provider);\n    error LockedBy(address locker, address hook);\n    error CurrencyNotSettled();\n\n    /**\n     * @notice Event emitted when a new book is opened\n     * @param id The book id\n     * @param base The base currency\n     * @param quote The quote currency\n     * @param unitSize The unit size of the book\n     * @param makerPolicy The maker fee policy\n     * @param takerPolicy The taker fee policy\n     * @param hooks The hooks contract\n     */\n    event Open(\n        BookId indexed id,\n        Currency indexed base,\n        Currency indexed quote,\n        uint64 unitSize,\n        FeePolicy makerPolicy,\n        FeePolicy takerPolicy,\n        IHooks hooks\n    );\n\n    /**\n     * @notice Event emitted when a new order is made\n     * @param bookId The book id\n     * @param user The user address\n     * @param tick The order tick\n     * @param orderIndex The order index\n     * @param unit The order unit\n     * @param provider The provider address\n     */\n    event Make(\n        BookId indexed bookId, address indexed user, Tick tick, uint256 orderIndex, uint64 unit, address provider\n    );\n\n    /**\n     * @notice Event emitted when an order is taken\n     * @param bookId The book id\n     * @param user The user address\n     * @param tick The order tick\n     * @param unit The order unit\n     */\n    event Take(BookId indexed bookId, address indexed user, Tick tick, uint64 unit);\n\n    /**\n     * @notice Event emitted when an order is canceled\n     * @param orderId The order id\n     * @param unit The canceled unit\n     */\n    event Cancel(OrderId indexed orderId, uint64 unit);\n\n    /**\n     * @notice Event emitted when an order is claimed\n     * @param orderId The order id\n     * @param unit The claimed unit\n     */\n    event Claim(OrderId indexed orderId, uint64 unit);\n\n    /**\n     * @notice Event emitted when a provider is whitelisted\n     * @param provider The provider address\n     */\n    event Whitelist(address indexed provider);\n\n    /**\n     * @notice Event emitted when a provider is delisted\n     * @param provider The provider address\n     */\n    event Delist(address indexed provider);\n\n    /**\n     * @notice Event emitted when a provider collects fees\n     * @param provider The provider address\n     * @param recipient The recipient address\n     * @param currency The currency\n     * @param amount The collected amount\n     */\n    event Collect(address indexed provider, address indexed recipient, Currency indexed currency, uint256 amount);\n\n    /**\n     * @notice Event emitted when new default provider is set\n     * @param newDefaultProvider The new default provider address\n     */\n    event SetDefaultProvider(address indexed newDefaultProvider);\n\n    /**\n     * @notice This structure represents a unique identifier for a book in the BookManager.\n     * @param base The base currency of the book\n     * @param unitSize The unit size of the book\n     * @param quote The quote currency of the book\n     * @param makerPolicy The maker fee policy of the book\n     * @param hooks The hooks contract of the book\n     * @param takerPolicy The taker fee policy of the book\n     */\n    struct BookKey {\n        Currency base;\n        uint64 unitSize;\n        Currency quote;\n        FeePolicy makerPolicy;\n        IHooks hooks;\n        FeePolicy takerPolicy;\n    }\n\n    /**\n     * @notice Returns the base URI\n     * @return The base URI\n     */\n    function baseURI() external view returns (string memory);\n\n    /**\n     * @notice Returns the contract URI\n     * @return The contract URI\n     */\n    function contractURI() external view returns (string memory);\n\n    /**\n     * @notice Returns the default provider\n     * @return The default provider\n     */\n    function defaultProvider() external view returns (address);\n\n    /**\n     * @notice Returns the total reserves of a given currency\n     * @param currency The currency in question\n     * @return The total reserves amount\n     */\n    function reservesOf(Currency currency) external view returns (uint256);\n\n    /**\n     * @notice Checks if a provider is whitelisted\n     * @param provider The address of the provider\n     * @return True if the provider is whitelisted, false otherwise\n     */\n    function isWhitelisted(address provider) external view returns (bool);\n\n    /**\n     * @notice Verifies if an owner has authorized a spender for a token\n     * @param owner The address of the token owner\n     * @param spender The address of the spender\n     * @param tokenId The token ID\n     */\n    function checkAuthorized(address owner, address spender, uint256 tokenId) external view;\n\n    /**\n     * @notice Calculates the amount owed to a provider in a given currency\n     * @param provider The provider's address\n     * @param currency The currency in question\n     * @return The owed amount\n     */\n    function tokenOwed(address provider, Currency currency) external view returns (uint256);\n\n    /**\n     * @notice Calculates the currency balance changes for a given locker\n     * @param locker The address of the locker\n     * @param currency The currency in question\n     * @return The net change in currency balance\n     */\n    function getCurrencyDelta(address locker, Currency currency) external view returns (int256);\n\n    /**\n     * @notice Retrieves the book key for a given book ID\n     * @param id The book ID\n     * @return The book key\n     */\n    function getBookKey(BookId id) external view returns (BookKey memory);\n\n    /**\n     * @notice This structure represents a current status for an order in the BookManager.\n     * @param provider The provider of the order\n     * @param open The open unit of the order\n     * @param claimable The claimable unit of the order\n     */\n    struct OrderInfo {\n        address provider;\n        uint64 open;\n        uint64 claimable;\n    }\n\n    /**\n     * @notice Provides information about an order\n     * @param id The order ID\n     * @return Order information including provider, open status, and claimable unit\n     */\n    function getOrder(OrderId id) external view returns (OrderInfo memory);\n\n    /**\n     * @notice Retrieves the locker and caller addresses for a given lock\n     * @param i The index of the lock\n     * @return locker The locker's address\n     * @return lockCaller The caller's address\n     */\n    function getLock(uint256 i) external view returns (address locker, address lockCaller);\n\n    /**\n     * @notice Provides the lock data\n     * @return The lock data including necessary numeric values\n     */\n    function getLockData() external view returns (uint128, uint128);\n\n    /**\n     * @notice Returns the depth of a given book ID and tick\n     * @param id The book ID\n     * @param tick The tick\n     * @return The depth of the tick\n     */\n    function getDepth(BookId id, Tick tick) external view returns (uint64);\n\n    /**\n     * @notice Retrieves the highest tick for a given book ID\n     * @param id The book ID\n     * @return tick The highest tick\n     */\n    function getHighest(BookId id) external view returns (Tick tick);\n\n    /**\n     * @notice Finds the maximum tick less than a specified tick in a book\n     * @dev Returns `Tick.wrap(type(int24).min)` if the specified tick is the lowest\n     * @param id The book ID\n     * @param tick The specified tick\n     * @return The next lower tick\n     */\n    function maxLessThan(BookId id, Tick tick) external view returns (Tick);\n\n    /**\n     * @notice Checks if a book is opened\n     * @param id The book ID\n     * @return True if the book is opened, false otherwise\n     */\n    function isOpened(BookId id) external view returns (bool);\n\n    /**\n     * @notice Checks if a book is empty\n     * @param id The book ID\n     * @return True if the book is empty, false otherwise\n     */\n    function isEmpty(BookId id) external view returns (bool);\n\n    /**\n     * @notice Encodes a BookKey into a BookId\n     * @param key The BookKey to encode\n     * @return The encoded BookId\n     */\n    function encodeBookKey(BookKey calldata key) external pure returns (BookId);\n\n    /**\n     * @notice Loads a value from a specific storage slot\n     * @param slot The storage slot\n     * @return The value in the slot\n     */\n    function load(bytes32 slot) external view returns (bytes32);\n\n    /**\n     * @notice Loads a sequence of values starting from a specific slot\n     * @param startSlot The starting slot\n     * @param nSlot The number of slots to load\n     * @return The sequence of values\n     */\n    function load(bytes32 startSlot, uint256 nSlot) external view returns (bytes memory);\n\n    /**\n     * @notice Opens a new book\n     * @param key The book key\n     * @param hookData The hook data\n     */\n    function open(BookKey calldata key, bytes calldata hookData) external;\n\n    /**\n     * @notice Locks a book manager function\n     * @param locker The locker address\n     * @param data The lock data\n     * @return The lock return data\n     */\n    function lock(address locker, bytes calldata data) external returns (bytes memory);\n\n    /**\n     * @notice This structure represents the parameters for making an order.\n     * @param key The book key for the order\n     * @param tick The tick for the order\n     * @param unit The unit for the order. Times key.unitSize to get actual bid amount.\n     * @param provider The provider for the order. The limit order service provider address to collect fees.\n     */\n    struct MakeParams {\n        BookKey key;\n        Tick tick;\n        uint64 unit;\n        address provider;\n    }\n\n    /**\n     * @notice Make a limit order\n     * @param params The order parameters\n     * @param hookData The hook data\n     * @return id The order id. Returns 0 if the order is not settled\n     * @return quoteAmount The amount of quote currency to be paid\n     */\n    function make(MakeParams calldata params, bytes calldata hookData)\n        external\n        returns (OrderId id, uint256 quoteAmount);\n\n    /**\n     * @notice This structure represents the parameters for taking orders in the specified tick.\n     * @param key The book key for the order\n     * @param tick The tick for the order\n     * @param maxUnit The max unit to take\n     */\n    struct TakeParams {\n        BookKey key;\n        Tick tick;\n        uint64 maxUnit;\n    }\n\n    /**\n     * @notice Take a limit order at specific tick\n     * @param params The order parameters\n     * @param hookData The hook data\n     * @return quoteAmount The amount of quote currency to be received\n     * @return baseAmount The amount of base currency to be paid\n     */\n    function take(TakeParams calldata params, bytes calldata hookData)\n        external\n        returns (uint256 quoteAmount, uint256 baseAmount);\n\n    /**\n     * @notice This structure represents the parameters for canceling an order.\n     * @param id The order id for the order\n     * @param toUnit The remaining open unit for the order after cancellation. Must not exceed the current open unit.\n     */\n    struct CancelParams {\n        OrderId id;\n        uint64 toUnit;\n    }\n\n    /**\n     * @notice Cancel a limit order\n     * @param params The order parameters\n     * @param hookData The hook data\n     * @return canceledAmount The amount of quote currency canceled\n     */\n    function cancel(CancelParams calldata params, bytes calldata hookData) external returns (uint256 canceledAmount);\n\n    /**\n     * @notice Claims an order\n     * @param id The order ID\n     * @param hookData The hook data\n     * @return claimedAmount The amount claimed\n     */\n    function claim(OrderId id, bytes calldata hookData) external returns (uint256 claimedAmount);\n\n    /**\n     * @notice Collects fees from a provider\n     * @param recipient The recipient address\n     * @param currency The currency\n     * @return The collected amount\n     */\n    function collect(address recipient, Currency currency) external returns (uint256);\n\n    /**\n     * @notice Withdraws a currency\n     * @param currency The currency\n     * @param to The recipient address\n     * @param amount The amount\n     */\n    function withdraw(Currency currency, address to, uint256 amount) external;\n\n    /**\n     * @notice Settles a currency\n     * @param currency The currency\n     * @return The settled amount\n     */\n    function settle(Currency currency) external payable returns (uint256);\n\n    /**\n     * @notice Whitelists a provider\n     * @param provider The provider address\n     */\n    function whitelist(address provider) external;\n\n    /**\n     * @notice Delists a provider\n     * @param provider The provider address\n     */\n    function delist(address provider) external;\n\n    /**\n     * @notice Sets the default provider\n     * @param newDefaultProvider The new default provider address\n     */\n    function setDefaultProvider(address newDefaultProvider) external;\n}\n"
    },
    "clober-dex/v2-core/interfaces/IERC721Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\n/**\n * @title IERC721Permit\n * @notice An interface for the ERC721 permit extension\n */\ninterface IERC721Permit is IERC721 {\n    error InvalidSignature();\n    error PermitExpired();\n\n    /**\n     * @notice The EIP-712 typehash for the permit struct used by the contract\n     */\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    /**\n     * @notice The EIP-712 domain separator for this contract\n     */\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    /**\n     * @notice Approve the spender to transfer the given tokenId\n     * @param spender The address to approve\n     * @param tokenId The tokenId to approve\n     * @param deadline The deadline for the signature\n     * @param v The recovery id of the signature\n     * @param r The r value of the signature\n     * @param s The s value of the signature\n     */\n    function permit(address spender, uint256 tokenId, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    /**\n     * @notice Get the current nonce for a token\n     * @param tokenId The tokenId to get the nonce for\n     * @return The current nonce\n     */\n    function nonces(uint256 tokenId) external view returns (uint256);\n}\n"
    },
    "clober-dex/v2-core/interfaces/IHooks.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {IBookManager} from \"./IBookManager.sol\";\nimport {OrderId} from \"../libraries/OrderId.sol\";\n\n/**\n * @title IHooks\n * @notice Interface for the hooks contract\n */\ninterface IHooks {\n    /**\n     * @notice Hook called before opening a new book\n     * @param sender The sender of the open transaction\n     * @param key The key of the book being opened\n     * @param hookData The data passed to the hook\n     * @return Returns the function selector if the hook is successful\n     */\n    function beforeOpen(address sender, IBookManager.BookKey calldata key, bytes calldata hookData)\n        external\n        returns (bytes4);\n\n    /**\n     * @notice Hook called after opening a new book\n     * @param sender The sender of the open transaction\n     * @param key The key of the book being opened\n     * @param hookData The data passed to the hook\n     * @return Returns the function selector if the hook is successful\n     */\n    function afterOpen(address sender, IBookManager.BookKey calldata key, bytes calldata hookData)\n        external\n        returns (bytes4);\n\n    /**\n     * @notice Hook called before making a new order\n     * @param sender The sender of the make transaction\n     * @param params The parameters of the make transaction\n     * @param hookData The data passed to the hook\n     * @return Returns the function selector if the hook is successful\n     */\n    function beforeMake(address sender, IBookManager.MakeParams calldata params, bytes calldata hookData)\n        external\n        returns (bytes4);\n\n    /**\n     * @notice Hook called after making a new order\n     * @param sender The sender of the make transaction\n     * @param params The parameters of the make transaction\n     * @param orderId The id of the order that was made\n     * @param hookData The data passed to the hook\n     * @return Returns the function selector if the hook is successful\n     */\n    function afterMake(\n        address sender,\n        IBookManager.MakeParams calldata params,\n        OrderId orderId,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /**\n     * @notice Hook called before taking an order\n     * @param sender The sender of the take transaction\n     * @param params The parameters of the take transaction\n     * @param hookData The data passed to the hook\n     * @return Returns the function selector if the hook is successful\n     */\n    function beforeTake(address sender, IBookManager.TakeParams calldata params, bytes calldata hookData)\n        external\n        returns (bytes4);\n\n    /**\n     * @notice Hook called after taking an order\n     * @param sender The sender of the take transaction\n     * @param params The parameters of the take transaction\n     * @param takenUnit The unit that was taken\n     * @param hookData The data passed to the hook\n     * @return Returns the function selector if the hook is successful\n     */\n    function afterTake(\n        address sender,\n        IBookManager.TakeParams calldata params,\n        uint64 takenUnit,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /**\n     * @notice Hook called before canceling an order\n     * @param sender The sender of the cancel transaction\n     * @param params The parameters of the cancel transaction\n     * @param hookData The data passed to the hook\n     * @return Returns the function selector if the hook is successful\n     */\n    function beforeCancel(address sender, IBookManager.CancelParams calldata params, bytes calldata hookData)\n        external\n        returns (bytes4);\n\n    /**\n     * @notice Hook called after canceling an order\n     * @param sender The sender of the cancel transaction\n     * @param params The parameters of the cancel transaction\n     * @param canceledUnit The unit that was canceled\n     * @param hookData The data passed to the hook\n     * @return Returns the function selector if the hook is successful\n     */\n    function afterCancel(\n        address sender,\n        IBookManager.CancelParams calldata params,\n        uint64 canceledUnit,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /**\n     * @notice Hook called before claiming an order\n     * @param sender The sender of the claim transaction\n     * @param orderId The id of the order being claimed\n     * @param hookData The data passed to the hook\n     * @return Returns the function selector if the hook is successful\n     */\n    function beforeClaim(address sender, OrderId orderId, bytes calldata hookData) external returns (bytes4);\n\n    /**\n     * @notice Hook called after claiming an order\n     * @param sender The sender of the claim transaction\n     * @param orderId The id of the order being claimed\n     * @param claimedUnit The unit that was claimed\n     * @param hookData The data passed to the hook\n     * @return Returns the function selector if the hook is successful\n     */\n    function afterClaim(address sender, OrderId orderId, uint64 claimedUnit, bytes calldata hookData)\n        external\n        returns (bytes4);\n}\n"
    },
    "clober-dex/v2-core/interfaces/ILocker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ILocker\n * @notice Interface for the locker contract\n */\ninterface ILocker {\n    /**\n     * @notice Called by the book manager on `msg.sender` when a lock is acquired\n     * @param data The data that was passed to the call to lock\n     * @return Any data that you want to be returned from the lock call\n     */\n    function lockAcquired(address lockCaller, bytes calldata data) external returns (bytes memory);\n}\n"
    },
    "clober-dex/v2-core/libraries/BookId.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.20;\n\nimport {IBookManager} from \"../interfaces/IBookManager.sol\";\n\ntype BookId is uint192;\n\nlibrary BookIdLibrary {\n    function toId(IBookManager.BookKey memory bookKey) internal pure returns (BookId id) {\n        bytes32 hash = keccak256(abi.encode(bookKey));\n        assembly {\n            id := and(hash, 0xffffffffffffffffffffffffffffffffffffffffffffffff)\n        }\n    }\n}\n"
    },
    "clober-dex/v2-core/libraries/Currency.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ntype Currency is address;\n\n/// @title CurrencyLibrary\n/// @dev This library allows for transferring and holding native tokens and ERC20 tokens\nlibrary CurrencyLibrary {\n    using CurrencyLibrary for Currency;\n\n    /// @notice Thrown when a native transfer fails\n    error NativeTransferFailed();\n\n    /// @notice Thrown when an ERC20 transfer fails\n    error ERC20TransferFailed();\n\n    Currency public constant NATIVE = Currency.wrap(address(0));\n\n    function transfer(Currency currency, address to, uint256 amount) internal {\n        // implementation from\n        // https://github.com/transmissions11/solmate/blob/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/SafeTransferLib.sol\n\n        bool success;\n        if (currency.isNative()) {\n            assembly {\n                // Transfer the ETH and store if it succeeded or not.\n                success := call(gas(), to, amount, 0, 0, 0, 0)\n            }\n\n            if (!success) revert NativeTransferFailed();\n        } else {\n            assembly {\n                // Get a pointer to some free memory.\n                let freeMemoryPointer := mload(0x40)\n\n                // Write the abi-encoded calldata into memory, beginning with the function selector.\n                mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n                mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n                mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n                success :=\n                    and(\n                        // Set success to whether the call reverted, if not we check it either\n                        // returned exactly 1 (can't just be non-zero data), or had no return data.\n                        or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                        // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                        // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                        // Counterintuitively, this call must be positioned second to the or() call in the\n                        // surrounding and() call or else returndatasize() will be zero during the computation.\n                        call(gas(), currency, 0, freeMemoryPointer, 68, 0, 32)\n                    )\n            }\n\n            if (!success) revert ERC20TransferFailed();\n        }\n    }\n\n    function balanceOfSelf(Currency currency) internal view returns (uint256) {\n        if (currency.isNative()) return address(this).balance;\n        else return IERC20(Currency.unwrap(currency)).balanceOf(address(this));\n    }\n\n    function equals(Currency currency, Currency other) internal pure returns (bool) {\n        return Currency.unwrap(currency) == Currency.unwrap(other);\n    }\n\n    function isNative(Currency currency) internal pure returns (bool) {\n        return Currency.unwrap(currency) == Currency.unwrap(NATIVE);\n    }\n\n    function toId(Currency currency) internal pure returns (uint256) {\n        return uint160(Currency.unwrap(currency));\n    }\n\n    function fromId(uint256 id) internal pure returns (Currency) {\n        return Currency.wrap(address(uint160(id)));\n    }\n}\n"
    },
    "clober-dex/v2-core/libraries/FeePolicy.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./Math.sol\";\n\ntype FeePolicy is uint24;\n\nlibrary FeePolicyLibrary {\n    uint256 internal constant RATE_PRECISION = 10 ** 6;\n    int256 internal constant MAX_FEE_RATE = 500000;\n    int256 internal constant MIN_FEE_RATE = -500000;\n\n    uint256 internal constant RATE_MASK = 0x7fffff; // 23 bits\n\n    error InvalidFeePolicy();\n\n    function encode(bool usesQuote_, int24 rate_) internal pure returns (FeePolicy feePolicy) {\n        if (rate_ > MAX_FEE_RATE || rate_ < MIN_FEE_RATE) {\n            revert InvalidFeePolicy();\n        }\n\n        uint256 mask = usesQuote_ ? 1 << 23 : 0;\n        assembly {\n            feePolicy := or(mask, add(and(rate_, 0xffffff), MAX_FEE_RATE))\n        }\n    }\n\n    function isValid(FeePolicy self) internal pure returns (bool) {\n        int24 r = rate(self);\n\n        return !(r > MAX_FEE_RATE || r < MIN_FEE_RATE);\n    }\n\n    function usesQuote(FeePolicy self) internal pure returns (bool f) {\n        assembly {\n            f := shr(23, self)\n        }\n    }\n\n    function rate(FeePolicy self) internal pure returns (int24 r) {\n        assembly {\n            r := sub(and(self, RATE_MASK), MAX_FEE_RATE)\n        }\n    }\n\n    function calculateFee(FeePolicy self, uint256 amount, bool reverseRounding) internal pure returns (int256 fee) {\n        int24 r = rate(self);\n\n        bool positive = r > 0;\n        uint256 absRate;\n        unchecked {\n            absRate = uint256(uint24(positive ? r : -r));\n        }\n        // @dev absFee must be less than type(int256).max\n        uint256 absFee = Math.divide(amount * absRate, RATE_PRECISION, reverseRounding ? !positive : positive);\n        fee = positive ? int256(absFee) : -int256(absFee);\n    }\n\n    function calculateOriginalAmount(FeePolicy self, uint256 amount, bool reverseFee)\n        internal\n        pure\n        returns (uint256 originalAmount)\n    {\n        int24 r = rate(self);\n\n        uint256 divider;\n        assembly {\n            if reverseFee { r := sub(0, r) }\n            divider := add(RATE_PRECISION, r)\n        }\n        originalAmount = Math.divide(amount * RATE_PRECISION, divider, reverseFee);\n    }\n}\n"
    },
    "clober-dex/v2-core/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nlibrary Math {\n    function divide(uint256 a, uint256 b, bool roundingUp) internal pure returns (uint256 ret) {\n        // In the OrderBook contract code, b is never zero.\n        assembly {\n            ret := add(div(a, b), and(gt(mod(a, b), 0), roundingUp))\n        }\n    }\n\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/22/exp-ln\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.\n            // We do this by multiplying by `2**96 / 10**18`. But since\n            // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here\n            // and add `ln(2**96 / 10**18)` at the end.\n\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // We place the check here for more optimal stack operations.\n            if iszero(sgt(x, 0)) {\n                mstore(0x00, 0x1615e638) // `LnWadUndefined()`.\n                revert(0x1c, 0x04)\n            }\n            // forgefmt: disable-next-item\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            x := shr(159, shl(r, x))\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // `p` is made monic, we will multiply by a scale factor later.\n            // forgefmt: disable-next-item\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\n                sar(96, mul(add(43456485725739037958740375743393,\n                    sar(96, mul(add(24828157081833163892658089445524,\n                        sar(96, mul(add(3273285459638523848632254066296,\n                            x), x))), x))), x)), 11111509109440967052023855526967)\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n\n            // `q` is monic by convention.\n            let q := add(5573035233440673466300451813936, x)\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\n\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\n\n            // Finalization, we need to:\n            // - Multiply by the scale factor `s = 5.549…`.\n            // - Add `ln(2**96 / 10**18)`.\n            // - Add `k * ln(2)`.\n            // - Multiply by `10**18 / 2**96 = 5**18 >> 78`.\n\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already `2**96` too large.\n            p := sdiv(p, q)\n            // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.\n            p := mul(1677202110996718588342820967067443963516166, p)\n            // Add `ln(2) * k * 5**18 * 2**192`.\n            // forgefmt: disable-next-item\n            p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)\n            // Base conversion: mul `2**96 / (5**18 * 2**192)`.\n            r := sdiv(p, 302231454903657293676544000000000000000000)\n        }\n    }\n}\n"
    },
    "clober-dex/v2-core/libraries/OrderId.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {Tick} from \"./Tick.sol\";\nimport {BookId} from \"./BookId.sol\";\n\ntype OrderId is uint256;\n\nlibrary OrderIdLibrary {\n    /**\n     * @dev Encode the order id.\n     * @param bookId The book id.\n     * @param tick The tick.\n     * @param index The index.\n     * @return id The order id.\n     */\n    function encode(BookId bookId, Tick tick, uint40 index) internal pure returns (OrderId id) {\n        // @dev If we just use tick at the assembly code, the code will convert tick into bytes32.\n        //      e.g. When index == -2, the shifted value( shl(40, tick) ) will be\n        //      0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0000000000 instead of 0xfffffffe0000000000\n        //      Therefore, we have to safely cast tick into uint256 first.\n        uint256 _tick = uint256(uint24(Tick.unwrap(tick)));\n        assembly {\n            id := add(index, add(shl(40, _tick), shl(64, bookId)))\n        }\n    }\n\n    function decode(OrderId id) internal pure returns (BookId bookId, Tick tick, uint40 index) {\n        assembly {\n            bookId := shr(64, id)\n            tick := and(shr(40, id), 0xffffff)\n            index := and(id, 0xffffffffff)\n        }\n    }\n\n    function getBookId(OrderId id) internal pure returns (BookId bookId) {\n        assembly {\n            bookId := shr(64, id)\n        }\n    }\n\n    function getTick(OrderId id) internal pure returns (Tick tick) {\n        assembly {\n            tick := and(shr(40, id), 0xffffff)\n        }\n    }\n\n    function getIndex(OrderId id) internal pure returns (uint40 index) {\n        assembly {\n            index := and(id, 0xffffffffff)\n        }\n    }\n}\n"
    },
    "clober-dex/v2-core/libraries/Tick.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./Math.sol\";\n\ntype Tick is int24;\n\nlibrary TickLibrary {\n    using Math for *;\n    using TickLibrary for Tick;\n\n    error InvalidTick();\n    error InvalidPrice();\n    error TickOverflow();\n\n    int24 internal constant MAX_TICK = 2 ** 19 - 1;\n    int24 internal constant MIN_TICK = -MAX_TICK;\n\n    uint256 internal constant MIN_PRICE = 1350587;\n    uint256 internal constant MAX_PRICE = 4647684107270898330752324302845848816923571339324334;\n\n    uint256 private constant _R0 = 0xfff97272373d413259a46990;\n    uint256 private constant _R1 = 0xfff2e50f5f656932ef12357c;\n    uint256 private constant _R2 = 0xffe5caca7e10e4e61c3624ea;\n    uint256 private constant _R3 = 0xffcb9843d60f6159c9db5883;\n    uint256 private constant _R4 = 0xff973b41fa98c081472e6896;\n    uint256 private constant _R5 = 0xff2ea16466c96a3843ec78b3;\n    uint256 private constant _R6 = 0xfe5dee046a99a2a811c461f1;\n    uint256 private constant _R7 = 0xfcbe86c7900a88aedcffc83b;\n    uint256 private constant _R8 = 0xf987a7253ac413176f2b074c;\n    uint256 private constant _R9 = 0xf3392b0822b70005940c7a39;\n    uint256 private constant _R10 = 0xe7159475a2c29b7443b29c7f;\n    uint256 private constant _R11 = 0xd097f3bdfd2022b8845ad8f7;\n    uint256 private constant _R12 = 0xa9f746462d870fdf8a65dc1f;\n    uint256 private constant _R13 = 0x70d869a156d2a1b890bb3df6;\n    uint256 private constant _R14 = 0x31be135f97d08fd981231505;\n    uint256 private constant _R15 = 0x9aa508b5b7a84e1c677de54;\n    uint256 private constant _R16 = 0x5d6af8dedb81196699c329;\n    uint256 private constant _R17 = 0x2216e584f5fa1ea92604;\n    uint256 private constant _R18 = 0x48a170391f7dc42;\n    uint256 private constant _R19 = 0x149b34;\n\n    function validateTick(Tick tick) internal pure {\n        if (Tick.unwrap(tick) > MAX_TICK || Tick.unwrap(tick) < MIN_TICK) revert InvalidTick();\n    }\n\n    modifier validatePrice(uint256 price) {\n        if (price > MAX_PRICE || price < MIN_PRICE) revert InvalidPrice();\n        _;\n    }\n\n    function fromPrice(uint256 price) internal pure validatePrice(price) returns (Tick) {\n        unchecked {\n            int24 tick = int24((int256(price).lnWad() * 42951820407860) / 2 ** 128);\n            if (toPrice(Tick.wrap(tick)) > price) return Tick.wrap(tick - 1);\n            return Tick.wrap(tick);\n        }\n    }\n\n    function toPrice(Tick tick) internal pure returns (uint256 price) {\n        validateTick(tick);\n        int24 tickValue = Tick.unwrap(tick);\n        uint256 absTick = uint24(tickValue < 0 ? -tickValue : tickValue);\n\n        unchecked {\n            if (absTick & 0x1 != 0) price = _R0;\n            else price = 1 << 96;\n            if (absTick & 0x2 != 0) price = (price * _R1) >> 96;\n            if (absTick & 0x4 != 0) price = (price * _R2) >> 96;\n            if (absTick & 0x8 != 0) price = (price * _R3) >> 96;\n            if (absTick & 0x10 != 0) price = (price * _R4) >> 96;\n            if (absTick & 0x20 != 0) price = (price * _R5) >> 96;\n            if (absTick & 0x40 != 0) price = (price * _R6) >> 96;\n            if (absTick & 0x80 != 0) price = (price * _R7) >> 96;\n            if (absTick & 0x100 != 0) price = (price * _R8) >> 96;\n            if (absTick & 0x200 != 0) price = (price * _R9) >> 96;\n            if (absTick & 0x400 != 0) price = (price * _R10) >> 96;\n            if (absTick & 0x800 != 0) price = (price * _R11) >> 96;\n            if (absTick & 0x1000 != 0) price = (price * _R12) >> 96;\n            if (absTick & 0x2000 != 0) price = (price * _R13) >> 96;\n            if (absTick & 0x4000 != 0) price = (price * _R14) >> 96;\n            if (absTick & 0x8000 != 0) price = (price * _R15) >> 96;\n            if (absTick & 0x10000 != 0) price = (price * _R16) >> 96;\n            if (absTick & 0x20000 != 0) price = (price * _R17) >> 96;\n            if (absTick & 0x40000 != 0) price = (price * _R18) >> 96;\n        }\n        if (tickValue > 0) price = 0x1000000000000000000000000000000000000000000000000 / price;\n    }\n\n    function gt(Tick a, Tick b) internal pure returns (bool) {\n        return Tick.unwrap(a) > Tick.unwrap(b);\n    }\n\n    function baseToQuote(Tick tick, uint256 base, bool roundingUp) internal pure returns (uint256) {\n        return Math.divide((base * tick.toPrice()), 1 << 96, roundingUp);\n    }\n\n    function quoteToBase(Tick tick, uint256 quote, bool roundingUp) internal pure returns (uint256) {\n        // @dev quote = unit(uint64) * unitSize(uint64) < 2^96\n        //      We don't need to check overflow here\n        return Math.divide(quote << 96, tick.toPrice(), roundingUp);\n    }\n}\n"
    },
    "solmate/tokens/ERC6909.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Minimalist and gas efficient standard ERC6909 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC6909.sol)\nabstract contract ERC6909 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OperatorSet(address indexed owner, address indexed operator, bool approved);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id, uint256 amount);\n\n    event Transfer(address caller, address indexed from, address indexed to, uint256 indexed id, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                             ERC6909 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => mapping(address => bool)) public isOperator;\n\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC6909 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transfer(\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) public virtual returns (bool) {\n        balanceOf[msg.sender][id] -= amount;\n\n        balanceOf[receiver][id] += amount;\n\n        emit Transfer(msg.sender, msg.sender, receiver, id, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) public virtual returns (bool) {\n        if (msg.sender != sender && !isOperator[sender][msg.sender]) {\n            uint256 allowed = allowance[sender][msg.sender][id];\n            if (allowed != type(uint256).max) allowance[sender][msg.sender][id] = allowed - amount;\n        }\n\n        balanceOf[sender][id] -= amount;\n\n        balanceOf[receiver][id] += amount;\n\n        emit Transfer(msg.sender, sender, receiver, id, amount);\n\n        return true;\n    }\n\n    function approve(\n        address spender,\n        uint256 id,\n        uint256 amount\n    ) public virtual returns (bool) {\n        allowance[msg.sender][spender][id] = amount;\n\n        emit Approval(msg.sender, spender, id, amount);\n\n        return true;\n    }\n\n    function setOperator(address operator, bool approved) public virtual returns (bool) {\n        isOperator[msg.sender][operator] = approved;\n\n        emit OperatorSet(msg.sender, operator, approved);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x0f632fb3; // ERC165 Interface ID for ERC6909\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[receiver][id] += amount;\n\n        emit Transfer(msg.sender, address(0), receiver, id, amount);\n    }\n\n    function _burn(\n        address sender,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[sender][id] -= amount;\n\n        emit Transfer(msg.sender, sender, address(0), id, amount);\n    }\n}\n"
    },
    "solmate/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // Divide x * y by the denominator.\n            z := div(mul(x, y), denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // If x * y modulo the denominator is strictly greater than 0,\n            // 1 is added to round up the division of x * y by the denominator.\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Mod x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            z := mod(x, y)\n        }\n    }\n\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Divide x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            r := div(x, y)\n        }\n    }\n\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Add 1 to x * y if x % y > 0. Note this will\n            // return 0 instead of reverting if y is zero.\n            z := add(gt(mod(x, y), 0), div(x, y))\n        }\n    }\n}\n"
    },
    "src/external/chainlink/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n    function latestRoundData()\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "src/external/chainlink/Common.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/*\n * @title Common\n * @author Michael Fletcher\n * @notice Common functions and structs\n */\nlibrary Common {\n    // @notice The asset struct to hold the address of an asset and amount\n    struct Asset {\n        address assetAddress;\n        uint256 amount;\n    }\n\n    // @notice Struct to hold the address and its associated weight\n    struct AddressAndWeight {\n        address addr;\n        uint64 weight;\n    }\n\n    /**\n     * @notice Checks if an array of AddressAndWeight has duplicate addresses\n     * @param recipients The array of AddressAndWeight to check\n     * @return bool True if there are duplicates, false otherwise\n     */\n    function _hasDuplicateAddresses(Common.AddressAndWeight[] memory recipients) internal pure returns (bool) {\n        for (uint256 i = 0; i < recipients.length;) {\n            for (uint256 j = i + 1; j < recipients.length;) {\n                if (recipients[i].addr == recipients[j].addr) {\n                    return true;\n                }\n                unchecked {\n                    ++j;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return false;\n    }\n}\n"
    },
    "src/external/chainlink/IFeeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./Common.sol\";\n\ninterface IFeeManager {\n    /**\n     * @notice Calculates the fee and reward associated with verifying a report, including discounts for subscribers.\n     * This function assesses the fee and reward for report verification, applying a discount for recognized subscriber addresses.\n     * @param subscriber The address attempting to verify the report. A discount is applied if this address\n     * is recognized as a subscriber.\n     * @param unverifiedReport The report data awaiting verification. The content of this report is used to\n     * determine the base fee and reward, before considering subscriber discounts.\n     * @param quoteAddress The payment token address used for quoting fees and rewards.\n     * @return fee The fee assessed for verifying the report, with subscriber discounts applied where applicable.\n     * @return reward The reward allocated to the caller for successfully verifying the report.\n     * @return totalDiscount The total discount amount deducted from the fee for subscribers.\n     */\n    function getFeeAndReward(address subscriber, bytes memory unverifiedReport, address quoteAddress)\n        external\n        returns (Common.Asset memory, Common.Asset memory, uint256);\n\n    function i_linkAddress() external view returns (address);\n\n    function i_nativeAddress() external view returns (address);\n\n    function i_rewardManager() external view returns (address);\n}\n"
    },
    "src/external/chainlink/ILogAutomation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @member index the index of the log in the block. 0 for the first log\n * @member timestamp the timestamp of the block containing the log\n * @member txHash the hash of the transaction containing the log\n * @member blockNumber the number of the block containing the log\n * @member blockHash the hash of the block containing the log\n * @member source the address of the contract that emitted the log\n * @member topics the indexed topics of the log\n * @member data the data of the log\n */\nstruct Log {\n    uint256 index;\n    uint256 timestamp;\n    bytes32 txHash;\n    uint256 blockNumber;\n    bytes32 blockHash;\n    address source;\n    bytes32[] topics;\n    bytes data;\n}\n\ninterface ILogAutomation {\n    /**\n     * @notice method that is simulated by the keepers to see if any work actually\n     * needs to be performed. This method does does not actually need to be\n     * executable, and since it is only ever simulated it can consume lots of gas.\n     * @dev To ensure that it is never called, you may want to add the\n     * cannotExecute modifier from KeeperBase to your implementation of this\n     * method.\n     * @param log the raw log data matching the filter that this contract has\n     * registered as a trigger\n     * @param checkData user-specified extra data to provide context to this upkeep\n     * @return upkeepNeeded boolean to indicate whether the keeper should call\n     * performUpkeep or not.\n     * @return performData bytes that the keeper should call performUpkeep with, if\n     * upkeep is needed. If you would like to encode data to decode later, try\n     * `abi.encode`.\n     */\n    function checkLog(Log calldata log, bytes memory checkData)\n        external\n        returns (bool upkeepNeeded, bytes memory performData);\n\n    /**\n     * @notice method that is actually executed by the keepers, via the registry.\n     * The data returned by the checkUpkeep simulation will be passed into\n     * this method to actually be executed.\n     * @dev The input to this method should not be trusted, and the caller of the\n     * method should not even be restricted to any single registry. Anyone should\n     * be able call it, and the input should be validated, there is no guarantee\n     * that the data passed in is the performData returned from checkUpkeep. This\n     * could happen due to malicious keepers, racing keepers, or simply a state\n     * change while the performUpkeep transaction is waiting for confirmation.\n     * Always validate the data passed in.\n     * @param performData is the data which was passed back from the checkData\n     * simulation. If it is encoded, it can easily be decoded into other types by\n     * calling `abi.decode`. This data should not be trusted, and should be\n     * validated against the contract's current state.\n     */\n    function performUpkeep(bytes calldata performData) external;\n}\n"
    },
    "src/external/chainlink/IRewardManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Common} from \"./Common.sol\";\n\ninterface IRewardManager is IERC165 {\n    /**\n     * @notice Record the fee received for a particular pool\n     * @param payments array of structs containing pool id and amount\n     * @param payee the user the funds should be retrieved from\n     */\n    function onFeePaid(FeePayment[] calldata payments, address payee) external;\n\n    /**\n     * @notice Claims the rewards in a specific pool\n     * @param poolIds array of poolIds to claim rewards for\n     */\n    function claimRewards(bytes32[] calldata poolIds) external;\n\n    /**\n     * @notice Set the RewardRecipients and weights for a specific pool. This should only be called once per pool Id. Else updateRewardRecipients should be used.\n     * @param poolId poolId to set RewardRecipients and weights for\n     * @param rewardRecipientAndWeights array of each RewardRecipient and associated weight\n     */\n    function setRewardRecipients(bytes32 poolId, Common.AddressAndWeight[] calldata rewardRecipientAndWeights)\n        external;\n\n    /**\n     * @notice Updates a subset the reward recipients for a specific poolId. The collective weight of the recipients should add up to the recipients existing weights. Any recipients with a weight of 0 will be removed.\n     * @param poolId the poolId to update\n     * @param newRewardRecipients array of new reward recipients\n     */\n    function updateRewardRecipients(bytes32 poolId, Common.AddressAndWeight[] calldata newRewardRecipients) external;\n\n    /**\n     * @notice Pays all the recipients for each of the pool ids\n     * @param poolId the pool id to pay recipients for\n     * @param recipients array of recipients to pay within the pool\n     */\n    function payRecipients(bytes32 poolId, address[] calldata recipients) external;\n\n    /**\n     * @notice Sets the fee manager. This needs to be done post construction to prevent a circular dependency.\n     * @param newFeeManager address of the new verifier proxy\n     */\n    function setFeeManager(address newFeeManager) external;\n\n    /**\n     * @notice Gets a list of pool ids which have reward for a specific recipient.\n     * @param recipient address of the recipient to get pool ids for\n     * @param startIndex the index to start from\n     * @param endIndex the index to stop at\n     */\n    function getAvailableRewardPoolIds(address recipient, uint256 startIndex, uint256 endIndex)\n        external\n        view\n        returns (bytes32[] memory);\n\n    /**\n     * @notice The structure to hold a fee payment notice\n     * @param poolId the poolId receiving the payment\n     * @param amount the amount being paid\n     */\n    struct FeePayment {\n        bytes32 poolId;\n        uint192 amount;\n    }\n}\n"
    },
    "src/external/chainlink/IVerifierFeeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Common} from \"./Common.sol\";\n\ninterface IVerifierFeeManager is IERC165 {\n    /**\n     * @notice Handles fees for a report from the subscriber and manages rewards\n     * @param payload report to process the fee for\n     * @param parameterPayload fee payload\n     * @param subscriber address of the fee will be applied\n     */\n    function processFee(bytes calldata payload, bytes calldata parameterPayload, address subscriber) external payable;\n\n    /**\n     * @notice Processes the fees for each report in the payload, billing the subscriber and paying the reward manager\n     * @param payloads reports to process\n     * @param parameterPayload fee payload\n     * @param subscriber address of the user to process fee for\n     */\n    function processFeeBulk(bytes[] calldata payloads, bytes calldata parameterPayload, address subscriber)\n        external\n        payable;\n\n    /**\n     * @notice Sets the fee recipients according to the fee manager\n     * @param configDigest digest of the configuration\n     * @param rewardRecipientAndWeights the address and weights of all the recipients to receive rewards\n     */\n    function setFeeRecipients(bytes32 configDigest, Common.AddressAndWeight[] calldata rewardRecipientAndWeights)\n        external;\n}\n"
    },
    "src/external/chainlink/IVerifierProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {IVerifierFeeManager} from \"./IVerifierFeeManager.sol\";\n\ninterface IVerifierProxy {\n    /**\n     * @notice Verifies that the data encoded has been signed.\n     * correctly by routing to the correct verifier, and bills the user if applicable.\n     * @param payload The encoded data to be verified, including the signed\n     * report.\n     * @param parameterPayload Fee metadata for billing. In the current implementation,\n     * this consists of the abi-encoded address of the ERC-20 token used for fees.\n     * @return verifierResponse The encoded report from the verifier.\n     */\n    function verify(bytes calldata payload, bytes calldata parameterPayload)\n        external\n        payable\n        returns (bytes memory verifierResponse);\n\n    function s_feeManager() external view returns (IVerifierFeeManager);\n}\n"
    },
    "src/external/chainlink/StreamsLookupCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface StreamsLookupCompatibleInterface {\n    error StreamsLookup(string feedParamKey, string[] feeds, string timeParamKey, uint256 time, bytes extraData);\n\n    /**\n     * @notice any contract which wants to utilize StreamsLookup feature needs to\n     * implement this interface as well as the automation compatible interface.\n     * @param values an array of bytes returned from data streams endpoint.\n     * @param extraData context data from streams lookup process.\n     * @return upkeepNeeded boolean to indicate whether the keeper should call performUpkeep or not.\n     * @return performData bytes that the keeper should call performUpkeep with, if\n     * upkeep is needed. If you would like to encode data to decode later, try `abi.encode`.\n     */\n    function checkCallback(bytes[] memory values, bytes memory extraData)\n        external\n        view\n        returns (bool upkeepNeeded, bytes memory performData);\n\n    /**\n     * @notice this is a new, optional function in streams lookup. It is meant to surface streams lookup errors.\n     * @param errCode an uint value that represents the streams lookup error code.\n     * @param extraData context data from streams lookup process.\n     * @return upkeepNeeded boolean to indicate whether the keeper should call performUpkeep or not.\n     * @return performData bytes that the keeper should call performUpkeep with, if\n     * upkeep is needed. If you would like to encode data to decode later, try `abi.encode`.\n     */\n    function checkErrorHandler(uint256 errCode, bytes memory extraData)\n        external\n        view\n        returns (bool upkeepNeeded, bytes memory performData);\n}\n"
    },
    "src/external/coupon-finance/Epoch.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.19;\n\ntype Epoch is uint16;\n\nusing {gt as >, gte as >=, lt as <, lte as <=, eq as ==, ne as !=} for Epoch global;\n\nfunction gt(Epoch a, Epoch b) pure returns (bool) {\n    return Epoch.unwrap(a) > Epoch.unwrap(b);\n}\n\nfunction gte(Epoch a, Epoch b) pure returns (bool) {\n    return Epoch.unwrap(a) >= Epoch.unwrap(b);\n}\n\nfunction lt(Epoch a, Epoch b) pure returns (bool) {\n    return Epoch.unwrap(a) < Epoch.unwrap(b);\n}\n\nfunction lte(Epoch a, Epoch b) pure returns (bool) {\n    return Epoch.unwrap(a) <= Epoch.unwrap(b);\n}\n\nfunction eq(Epoch a, Epoch b) pure returns (bool) {\n    return Epoch.unwrap(a) == Epoch.unwrap(b);\n}\n\nfunction ne(Epoch a, Epoch b) pure returns (bool) {\n    return Epoch.unwrap(a) != Epoch.unwrap(b);\n}\n\nlibrary EpochLibrary {\n    using EpochLibrary for Epoch;\n\n    error EpochOverflow();\n\n    uint256 internal constant MONTHS_PER_EPOCH = 1;\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\n    int256 constant OFFSET19700101 = 2440588;\n\n    function startTime(Epoch epoch) internal pure returns (uint256) {\n        uint16 currentEpoch = Epoch.unwrap(epoch);\n        if (currentEpoch == 0) return 0;\n        unchecked {\n            return _epochToTimestamp(currentEpoch - 1) + 1;\n        }\n    }\n\n    function endTime(Epoch epoch) internal pure returns (uint256) {\n        return _epochToTimestamp(Epoch.unwrap(epoch));\n    }\n\n    function lastExpiredEpoch() internal view returns (Epoch) {\n        return current().sub(1);\n    }\n\n    function current() internal view returns (Epoch) {\n        return Epoch.wrap(_timestampToEpoch(block.timestamp));\n    }\n\n    function add(Epoch epoch, uint16 epochs) internal pure returns (Epoch) {\n        return Epoch.wrap(Epoch.unwrap(epoch) + epochs);\n    }\n\n    function sub(Epoch epoch, uint16 epochs) internal pure returns (Epoch) {\n        return Epoch.wrap(Epoch.unwrap(epoch) - epochs);\n    }\n\n    function sub(Epoch e1, Epoch e2) internal pure returns (uint16) {\n        return Epoch.unwrap(e1) - Epoch.unwrap(e2);\n    }\n\n    function max(Epoch a, Epoch b) internal pure returns (Epoch) {\n        return a > b ? a : b;\n    }\n\n    // Inspired by https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary/blob/master/contracts/BokkyPooBahsDateTimeLibrary.sol\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _timestampToEpoch(uint256 timestamp) private pure returns (uint16) {\n        unchecked {\n            uint256 _days = timestamp / SECONDS_PER_DAY;\n            int256 __days = int256(_days);\n\n            int256 L = __days + 68569 + OFFSET19700101;\n            int256 N = (4 * L) / 146097;\n            L = L - (146097 * N + 3) / 4;\n            int256 _year = (4000 * (L + 1)) / 1461001;\n            L = L - (1461 * _year) / 4 + 31;\n            int256 _month = (80 * L) / 2447;\n            L = _month / 11;\n            _month = _month + 2 - 12 * L;\n            _year = 100 * (N - 49) + _year + L;\n\n            uint256 epoch = uint256((_year - 1970) * 12 + _month - 1) / MONTHS_PER_EPOCH;\n            if (epoch > type(uint16).max) revert EpochOverflow();\n            return uint16(epoch);\n        }\n    }\n\n    function _epochToTimestamp(uint16 epoch) internal pure returns (uint256) {\n        unchecked {\n            uint256 months = MONTHS_PER_EPOCH + MONTHS_PER_EPOCH * epoch;\n            uint256 year = months / 12 + 1970;\n            months = (months % 12) << 4;\n            if (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0)) {\n                // 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366\n                months = 0x016E014F0131011200F400D500B600980079005B003C001F0000 >> months;\n            } else {\n                // 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365\n                months = 0x016D014E0130011100F300D400B500970078005A003B001F0000 >> months;\n            }\n            return (\n                (months & 0xffff) + 365 * (year - 1970) + (year - 1969) / 4 - (year - 1901) / 100 + (year - 1601) / 400\n            ) * SECONDS_PER_DAY - 1;\n        }\n    }\n}\n"
    },
    "src/interfaces/IChainlinkOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {IOracle} from \"./IOracle.sol\";\n\ninterface IChainlinkOracle is IOracle {\n    error LengthMismatch();\n    error InvalidTimeout();\n    error InvalidGracePeriod();\n\n    event SetSequencerOracle(address indexed newSequencerOracle);\n    event SetTimeout(uint256 newTimeout);\n    event SetGracePeriod(uint256 newGracePeriod);\n    event SetFallbackOracle(address indexed newFallbackOracle);\n    event SetFeed(address indexed asset, address[] feeds);\n\n    function sequencerOracle() external view returns (address);\n\n    function timeout() external view returns (uint256);\n\n    function gracePeriod() external view returns (uint256);\n\n    function fallbackOracle() external view returns (address);\n\n    function getFeeds(address asset) external view returns (address[] memory);\n\n    function isSequencerValid() external view returns (bool);\n\n    function setFallbackOracle(address newFallbackOracle) external;\n\n    function setFeeds(address[] calldata assets, address[][] calldata feeds) external;\n\n    function setSequencerOracle(address newSequencerOracle) external;\n\n    function setTimeout(uint256 newTimeout) external;\n\n    function setGracePeriod(uint256 newGracePeriod) external;\n}\n"
    },
    "src/interfaces/IDatastreamOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {IOracle} from \"./IOracle.sol\";\n\ninterface IDatastreamOracle is IOracle {\n    error AlreadySetFeed();\n    error InvalidForwarder();\n    error InvalidReport();\n    error NotOperator();\n\n    struct FeedData {\n        address asset;\n        uint96 index;\n    }\n\n    struct Report {\n        bytes32 feedId; // The feed ID the report has data for\n        uint32 validFromTimestamp; // Earliest timestamp for which price is applicable\n        uint32 observationsTimestamp; // Latest timestamp for which price is applicable\n        uint192 nativeFee; // Base cost to validate a transaction using the report, denominated in the chain’s native token (WETH/ETH)\n        uint192 linkFee; // Base cost to validate a transaction using the report, denominated in LINK\n        uint32 expiresAt; // Latest timestamp where the report can be verified onchain\n        int192 price; // DON consensus median price, carried to 8 decimal places\n        int192 bid; // Simulated price impact of a buy order up to the X% depth of liquidity utilisation\n        int192 ask; // Simulated price impact of a sell order up to the X% depth of liquidity utilisation\n    }\n\n    event SetForwarder(address indexed forwarder);\n    event SetFeed(address indexed asset, bytes32 feedId, uint256 index);\n    event SetPrice(address indexed asset, uint256 price);\n    event SetFallbackOracle(address indexed newFallbackOracle);\n    event SetOperator(address indexed operator, bool status);\n    event Request(address indexed requester, uint256 bitmap);\n\n    function isOperator(address account) external view returns (bool);\n\n    function fallbackOracle() external view returns (address);\n\n    function setFallbackOracle(address newFallbackOracle) external;\n\n    function setFeed(bytes32 feedId, address asset) external;\n\n    function setForwarder(address newForwarder) external;\n\n    function setOperator(address operator, bool status) external;\n\n    function getFeedIds() external view returns (bytes32[] memory);\n\n    function getAllFeedData() external view returns (bytes32[] memory feedIds, FeedData[] memory data);\n\n    function forwarder() external view returns (address);\n\n    function feeToken() external view returns (address);\n\n    function feeBalance() external view returns (uint256);\n\n    function feedData(bytes32 feedId) external view returns (FeedData memory);\n\n    function request(uint256 bitmap) external;\n}\n"
    },
    "src/interfaces/IMinter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport \"../libraries/PermitParams.sol\";\nimport \"../Rebalancer.sol\";\n\ninterface IMinter {\n    error RouterSwapFailed(bytes message);\n\n    struct SwapParams {\n        Currency inCurrency;\n        uint256 amount;\n        bytes data;\n    }\n\n    function bookManager() external view returns (IBookManager);\n\n    function rebalancer() external view returns (Rebalancer);\n\n    function router() external view returns (address);\n\n    function mint(\n        bytes32 key,\n        uint256 amountA,\n        uint256 amountB,\n        uint256 minLpAmount,\n        ERC20PermitParams calldata currencyAPermitParams,\n        ERC20PermitParams calldata currencyBPermitParams,\n        SwapParams calldata swapParams\n    ) external payable;\n}\n"
    },
    "src/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\ninterface IOracle {\n    /**\n     * @notice Retrieves the number of decimals used by the oracle.\n     * @return The number of decimals.\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @notice Retrieves the price of a specified asset.\n     * @param asset The address of the asset.\n     * @return The price of the asset.\n     */\n    function getAssetPrice(address asset) external view returns (uint256);\n\n    /**\n     * @notice Retrieves the prices of a list of specified assets.\n     * @param assets The list of asset addresses.\n     * @return The list of prices for the specified assets.\n     */\n    function getAssetsPrices(address[] calldata assets) external view returns (uint256[] memory);\n}\n"
    },
    "src/interfaces/IRebalancer.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {IBookManager} from \"clober-dex/v2-core/interfaces/IBookManager.sol\";\nimport {BookId} from \"clober-dex/v2-core/libraries/BookId.sol\";\nimport {BookId} from \"clober-dex/v2-core/libraries/BookId.sol\";\nimport {OrderId} from \"clober-dex/v2-core/libraries/OrderId.sol\";\n\nimport {IStrategy} from \"./IStrategy.sol\";\n\ninterface IRebalancer {\n    struct Pool {\n        BookId bookIdA;\n        BookId bookIdB;\n        IStrategy strategy;\n        uint256 reserveA;\n        uint256 reserveB;\n        OrderId[] orderListA;\n        OrderId[] orderListB;\n    }\n\n    error NotSelf();\n    error InvalidHook();\n    error InvalidStrategy();\n    error InvalidBookPair();\n    error AlreadyOpened();\n    error InvalidLockAcquiredSender();\n    error InvalidLockCaller();\n    error LockFailure();\n    error InvalidMaker();\n    error InvalidAmount();\n    error InvalidValue();\n    error Slippage();\n\n    event Open(bytes32 indexed key, BookId indexed bookIdA, BookId indexed bookIdB, bytes32 salt, address strategy);\n    event Mint(address indexed user, bytes32 indexed key, uint256 amountA, uint256 amountB, uint256 lpAmount);\n    event Burn(address indexed user, bytes32 indexed key, uint256 amountA, uint256 amountB, uint256 lpAmount);\n    event Rebalance(bytes32 indexed key);\n    event Claim(bytes32 indexed key, uint256 claimedAmountA, uint256 claimedAmountB);\n    event Cancel(bytes32 indexed key, uint256 canceledAmountA, uint256 canceledAmountB);\n\n    struct Liquidity {\n        uint256 reserve;\n        uint256 claimable;\n        uint256 cancelable;\n    }\n\n    /**\n     * @notice Retrieves the book pair for a specified book ID.\n     * @param bookId The book ID.\n     * @return The book pair.\n     */\n    function bookPair(BookId bookId) external view returns (BookId);\n\n    /**\n     * @notice Retrieves the pool for a specified key.\n     * @param key The key of the pool.\n     * @return The pool.\n     */\n    function getPool(bytes32 key) external view returns (Pool memory);\n\n    /**\n     * @notice Retrieves the book pairs for a specified key.\n     * @param key The key of the pool.\n     * @return bookIdA The book ID for the first book.\n     * @return bookIdB The book ID for the second book.\n     */\n    function getBookPairs(bytes32 key) external view returns (BookId bookIdA, BookId bookIdB);\n\n    /**\n     * @notice Retrieves the liquidity for a specified key.\n     * @param key The key of the pool.\n     * @return liquidityA The liquidity for the first token.\n     * @return liquidityB The liquidity for the second token.\n     */\n    function getLiquidity(bytes32 key)\n        external\n        view\n        returns (Liquidity memory liquidityA, Liquidity memory liquidityB);\n\n    /**\n     * @notice Opens a new pool with the specified parameters.\n     * @param bookKeyA The book key for the first book.\n     * @param bookKeyB The book key for the second book.\n     * @param salt The salt value.\n     * @param strategy The address of the strategy.\n     * @return key The key of the opened pool.\n     */\n    function open(\n        IBookManager.BookKey calldata bookKeyA,\n        IBookManager.BookKey calldata bookKeyB,\n        bytes32 salt,\n        address strategy\n    ) external returns (bytes32 key);\n\n    /**\n     * @notice Mints liquidity for the specified key.\n     * @param key The key of the pool.\n     * @param amountA The amount of the first token.\n     * @param amountB The amount of the second token.\n     * @param minLpAmount The minimum amount of liquidity tokens to mint.\n     * @return The amount of liquidity tokens minted.\n     */\n    function mint(bytes32 key, uint256 amountA, uint256 amountB, uint256 minLpAmount)\n        external\n        payable\n        returns (uint256);\n\n    /**\n     * @notice Burns liquidity for the specified key.\n     * @param key The key of the pool.\n     * @param amount The amount of liquidity tokens to burn.\n     * @param minAmountA The amount of the first token to receive.\n     * @param minAmountB The minimum amount of the second token to receive.\n     * @return The amounts of the first and second tokens to receive.\n     */\n    function burn(bytes32 key, uint256 amount, uint256 minAmountA, uint256 minAmountB)\n        external\n        returns (uint256, uint256);\n\n    /**\n     * @notice Rebalances the pool for the specified key.\n     * @param key The key of the pool.\n     */\n    function rebalance(bytes32 key) external;\n}\n"
    },
    "src/interfaces/ISimpleOracleStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {Tick} from \"clober-dex/v2-core/libraries/Tick.sol\";\nimport {IBookManager} from \"clober-dex/v2-core/interfaces/IBookManager.sol\";\n\nimport {IStrategy} from \"./IStrategy.sol\";\nimport {IOracle} from \"./IOracle.sol\";\nimport \"./IRebalancer.sol\";\n\ninterface ISimpleOracleStrategy is IStrategy {\n    error InvalidPrice();\n    error InvalidAccess();\n    error InvalidOraclePrice();\n    error InvalidConfig();\n    error InvalidValue();\n    error ExceedsThreshold();\n    error NotOperator();\n    error Paused();\n\n    event SetOperator(address indexed operator, bool status);\n    event UpdateConfig(bytes32 indexed key, Config config);\n    event UpdatePosition(bytes32 indexed key, uint256 oraclePrice, Tick tickA, Tick tickB, uint256 rate);\n    event Pause(bytes32 indexed key);\n    event Unpause(bytes32 indexed key);\n\n    struct Config {\n        uint24 referenceThreshold;\n        uint24 rebalanceThreshold;\n        uint24 rateA;\n        uint24 rateB;\n        uint24 minRateA;\n        uint24 minRateB;\n        uint24 priceThresholdA;\n        uint24 priceThresholdB;\n    }\n\n    struct Position {\n        bool paused;\n        uint128 oraclePrice;\n        uint24 rate;\n        Tick tickA;\n        Tick tickB;\n    }\n\n    function referenceOracle() external view returns (IOracle);\n\n    function bookManager() external view returns (IBookManager);\n\n    function isOperator(address operator) external view returns (bool);\n\n    function getConfig(bytes32 key) external view returns (Config memory);\n\n    function getPosition(bytes32 key) external view returns (Position memory);\n\n    function getLastRawAmount(bytes32 key) external view returns (uint256, uint256);\n\n    function isOraclePriceValid(bytes32 key) external view returns (bool);\n\n    function isPaused(bytes32 key) external view returns (bool);\n\n    function pause(bytes32 key) external;\n\n    function unpause(bytes32 key) external;\n\n    function updatePosition(bytes32 key, uint256 oraclePrice, Tick tickA, Tick tickB, uint24 rate) external;\n\n    function setConfig(bytes32 key, Config memory config) external;\n\n    function setOperator(address operator, bool status) external;\n}\n"
    },
    "src/interfaces/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {BookId} from \"clober-dex/v2-core/libraries/BookId.sol\";\nimport {Tick} from \"clober-dex/v2-core/libraries/Tick.sol\";\n\ninterface IStrategy {\n    struct Order {\n        Tick tick;\n        uint64 rawAmount;\n    }\n\n    /**\n     * @notice Retrieves the orders for a specified key.\n     * @param key The key of the pool.\n     * @return ordersA The orders for the first token.\n     * @return ordersB The orders for the second token.\n     * @dev Clears pool orders if an error occurs and retains current orders if the list is empty.\n     */\n    function computeOrders(bytes32 key) external view returns (Order[] memory ordersA, Order[] memory ordersB);\n\n    /**\n     * @notice Hook that is called after minting.\n     * @param sender The address of the sender.\n     * @param key The key of the pool.\n     * @param mintAmount The amount minted.\n     * @param lastTotalSupply The total supply before minting.\n     */\n    function mintHook(address sender, bytes32 key, uint256 mintAmount, uint256 lastTotalSupply) external;\n\n    /**\n     * @notice Hook that is called after burning.\n     * @param sender The address of the sender.\n     * @param key The key of the pool.\n     * @param burnAmount The amount burned.\n     * @param lastTotalSupply The total supply before burning.\n     */\n    function burnHook(address sender, bytes32 key, uint256 burnAmount, uint256 lastTotalSupply) external;\n\n    /**\n     * @notice Hook that is called after rebalancing.\n     * @param sender The address of the sender.\n     * @param key The key of the pool.\n     * @param liquidityA The liquidity orders for the first token.\n     * @param liquidityB The liquidity orders for the second token.\n     */\n    function rebalanceHook(address sender, bytes32 key, Order[] memory liquidityA, Order[] memory liquidityB)\n        external;\n}\n"
    },
    "src/libraries/ERC6909Supply.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {ERC6909} from \"solmate/tokens/ERC6909.sol\";\n\nabstract contract ERC6909Supply is ERC6909 {\n    mapping(uint256 => uint256) public totalSupply;\n\n    function _mint(address receiver, uint256 id, uint256 amount) internal virtual override {\n        super._mint(receiver, id, amount);\n        totalSupply[id] += amount;\n    }\n\n    function _burn(address sender, uint256 id, uint256 amount) internal virtual override {\n        super._burn(sender, id, amount);\n        totalSupply[id] -= amount;\n    }\n}\n"
    },
    "src/libraries/PermitParams.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {IERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\n\nstruct ERC20PermitParams {\n    uint256 permitAmount;\n    PermitSignature signature;\n}\n\nstruct PermitSignature {\n    uint256 deadline;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\n\nlibrary PermitParamsLibrary {\n    function tryPermit(ERC20PermitParams memory params, address token, address from, address to)\n        internal\n        returns (bool)\n    {\n        return tryPermit(params.signature, IERC20Permit(token), params.permitAmount, from, to);\n    }\n\n    function tryPermit(PermitSignature memory params, IERC20Permit token, uint256 amount, address from, address to)\n        internal\n        returns (bool)\n    {\n        if (params.deadline > 0) {\n            try token.permit(from, to, amount, params.deadline, params.v, params.r, params.s) {\n                return true;\n            } catch {}\n        }\n        return false;\n    }\n}\n"
    },
    "src/Minter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IMinter.sol\";\n\ncontract Minter is IMinter {\n    using CurrencyLibrary for Currency;\n    using PermitParamsLibrary for *;\n    using SafeERC20 for IERC20;\n\n    IBookManager public immutable bookManager;\n    Rebalancer public immutable rebalancer;\n    address public immutable router;\n\n    constructor(address _bookManager, address payable _rebalancer, address _router) {\n        bookManager = IBookManager(_bookManager);\n        rebalancer = Rebalancer(_rebalancer);\n        router = _router;\n    }\n\n    function mint(\n        bytes32 key,\n        uint256 amountA,\n        uint256 amountB,\n        uint256 minLpAmount,\n        ERC20PermitParams calldata currencyAPermitParams,\n        ERC20PermitParams calldata currencyBPermitParams,\n        SwapParams calldata swapParams\n    ) external payable {\n        (BookId bookIdA,) = rebalancer.getBookPairs(key);\n        IBookManager.BookKey memory bookKey = IBookManager(bookManager).getBookKey(bookIdA);\n\n        currencyAPermitParams.tryPermit(Currency.unwrap(bookKey.quote), msg.sender, address(this));\n        currencyBPermitParams.tryPermit(Currency.unwrap(bookKey.base), msg.sender, address(this));\n\n        if (!bookKey.quote.isNative()) {\n            IERC20(Currency.unwrap(bookKey.quote)).safeTransferFrom(msg.sender, address(this), amountA);\n        }\n\n        if (!bookKey.base.isNative()) {\n            IERC20(Currency.unwrap(bookKey.base)).safeTransferFrom(msg.sender, address(this), amountB);\n        }\n\n        if (swapParams.data.length > 0) {\n            _swap(swapParams);\n        }\n\n        uint256 lpAmount = _mint(key, bookKey.quote, bookKey.base, minLpAmount);\n\n        rebalancer.transfer(msg.sender, uint256(key), lpAmount);\n\n        uint256 balance = bookKey.quote.balanceOfSelf();\n        if (balance > 0) bookKey.quote.transfer(msg.sender, balance);\n        balance = bookKey.base.balanceOfSelf();\n        if (balance > 0) bookKey.base.transfer(msg.sender, balance);\n    }\n\n    function _swap(SwapParams calldata swapParams) internal {\n        uint256 value = swapParams.inCurrency.isNative() ? swapParams.amount : 0;\n        _approve(swapParams.inCurrency, router, swapParams.amount);\n\n        (bool success, bytes memory result) = router.call{value: value}(swapParams.data);\n        if (!success) revert RouterSwapFailed(result);\n\n        _approve(swapParams.inCurrency, router, 0);\n    }\n\n    function _mint(bytes32 key, Currency quote, Currency base, uint256 minLpAmount)\n        internal\n        returns (uint256 lpAmount)\n    {\n        uint256 quoteBalance = quote.balanceOfSelf();\n        uint256 baseBalance = base.balanceOfSelf();\n        _approve(quote, address(rebalancer), quoteBalance);\n        _approve(base, address(rebalancer), baseBalance);\n        lpAmount = rebalancer.mint{value: address(this).balance}(key, quoteBalance, baseBalance, minLpAmount);\n        _approve(quote, address(rebalancer), 0);\n        _approve(base, address(rebalancer), 0);\n    }\n\n    function _approve(Currency currency, address spender, uint256 amount) internal {\n        if (!currency.isNative()) {\n            IERC20(Currency.unwrap(currency)).approve(spender, amount);\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "src/mocks/MockSwap.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.20;\n\nimport {IERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract MockSwap {\n    using SafeERC20 for IERC20;\n\n    function swap(address tokenIn, uint256 amountIn, address tokenOut, uint256 amountOut) external {\n        IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n        IERC20(tokenOut).safeTransfer(msg.sender, amountOut);\n    }\n\n    function swapEthForToken(address tokenOut, uint256 amountOut) external payable {\n        require(msg.value > 0, \"MockSwap: ETH value must be greater than 0\");\n        IERC20(tokenOut).safeTransfer(msg.sender, amountOut);\n    }\n}\n"
    },
    "src/Operator.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {Ownable, Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {Currency, CurrencyLibrary} from \"clober-dex/v2-core/libraries/Currency.sol\";\n\nimport \"./interfaces/ISimpleOracleStrategy.sol\";\nimport \"./interfaces/IRebalancer.sol\";\nimport {IDatastreamOracle} from \"./interfaces/IDatastreamOracle.sol\";\n\ncontract Operator is UUPSUpgradeable, Initializable, Ownable2Step {\n    using CurrencyLibrary for Currency;\n\n    IRebalancer public immutable rebalancer;\n    IDatastreamOracle public immutable datastreamOracle;\n\n    constructor(IRebalancer rebalancer_, IDatastreamOracle datastreamOracle_) Ownable(msg.sender) {\n        rebalancer = rebalancer_;\n        datastreamOracle = datastreamOracle_;\n    }\n\n    function initialize(address initialOwner) external initializer {\n        _transferOwnership(initialOwner);\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n    function updatePosition(bytes32 key, uint256 oraclePrice, Tick tickA, Tick tickB, uint24 rate) external onlyOwner {\n        ISimpleOracleStrategy oracleStrategy = ISimpleOracleStrategy(address(rebalancer.getPool(key).strategy));\n        if (oracleStrategy.isPaused(key)) {\n            oracleStrategy.unpause(key);\n        }\n        oracleStrategy.updatePosition(key, oraclePrice, tickA, tickB, rate);\n        rebalancer.rebalance(key);\n    }\n\n    function pause(bytes32 key) external onlyOwner {\n        ISimpleOracleStrategy(address(rebalancer.getPool(key).strategy)).pause(key);\n        rebalancer.rebalance(key);\n    }\n\n    function requestOraclePublic() external {\n        address feeToken = datastreamOracle.feeToken();\n        IERC20(feeToken).transferFrom(msg.sender, address(this), (10 ** IERC20Metadata(feeToken).decimals()) / 20);\n        datastreamOracle.request(type(uint256).max);\n    }\n\n    function requestOracle(uint256 bitmap) external onlyOwner {\n        datastreamOracle.request(bitmap);\n    }\n\n    function withdraw(Currency currency, address to, uint256 amount) external onlyOwner {\n        currency.transfer(to, amount);\n    }\n}\n"
    },
    "src/oracle/ChainlinkOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {Ownable, Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n\nimport {AggregatorV3Interface} from \"../external/chainlink/AggregatorV3Interface.sol\";\nimport {IOracle} from \"../interfaces/IOracle.sol\";\nimport {IChainlinkOracle} from \"../interfaces/IChainlinkOracle.sol\";\n\ncontract ChainlinkOracle is IChainlinkOracle, Ownable2Step {\n    uint256 private constant _MAX_TIMEOUT = 1 days;\n    uint256 private constant _MIN_TIMEOUT = 20 minutes;\n    uint256 private constant _MAX_GRACE_PERIOD = 1 days;\n    uint256 private constant _MIN_GRACE_PERIOD = 20 minutes;\n\n    uint256 public override timeout;\n    address public override sequencerOracle;\n    uint256 public override gracePeriod;\n    address public override fallbackOracle;\n    mapping(address => address[]) private _feeds;\n\n    constructor(address sequencerOracle_, uint256 timeout_, uint256 gracePeriod_, address initialOwner)\n        Ownable(initialOwner)\n    {\n        _setSequencerOracle(sequencerOracle_);\n        _setTimeout(timeout_);\n        _setGracePeriod(gracePeriod_);\n    }\n\n    function decimals() external pure returns (uint8) {\n        return 8;\n    }\n\n    function getFeeds(address asset) external view returns (address[] memory) {\n        return _feeds[asset];\n    }\n\n    function getAssetPrice(address asset) public view returns (uint256) {\n        address[] memory feeds = _feeds[asset];\n        if (feeds.length == 0) {\n            return IOracle(fallbackOracle).getAssetPrice(asset);\n        }\n        uint256 price = 10 ** 8;\n        for (uint256 i = 0; i < feeds.length; ++i) {\n            try AggregatorV3Interface(feeds[i]).latestRoundData() returns (\n                uint80 roundId, int256 answer, uint256, /* startedAt */ uint256 updatedAt, uint80 /* answeredInRound */\n            ) {\n                if (\n                    roundId != 0 && answer >= 0 && updatedAt <= block.timestamp\n                        && block.timestamp <= updatedAt + timeout && _isSequencerValid()\n                ) {\n                    uint256 feedDecimals = AggregatorV3Interface(feeds[i]).decimals();\n                    price = price * uint256(answer) / 10 ** feedDecimals;\n                    continue;\n                }\n            } catch {}\n            return IOracle(fallbackOracle).getAssetPrice(asset);\n        }\n        return price;\n    }\n\n    function getAssetsPrices(address[] memory assets) external view returns (uint256[] memory prices) {\n        prices = new uint256[](assets.length);\n        unchecked {\n            for (uint256 i = 0; i < assets.length; ++i) {\n                prices[i] = getAssetPrice(assets[i]);\n            }\n        }\n    }\n\n    function isSequencerValid() external view returns (bool) {\n        return _isSequencerValid();\n    }\n\n    function setFallbackOracle(address newFallbackOracle) external onlyOwner {\n        fallbackOracle = newFallbackOracle;\n        emit SetFallbackOracle(newFallbackOracle);\n    }\n\n    function setFeeds(address[] calldata assets, address[][] calldata feeds) external onlyOwner {\n        if (assets.length != feeds.length) revert LengthMismatch();\n\n        for (uint256 i = 0; i < assets.length; ++i) {\n            if (feeds[i].length == 0) revert LengthMismatch();\n            address[] storage _f = _feeds[assets[i]];\n            assembly {\n                sstore(_f.slot, 0)\n            }\n            for (uint256 j = 0; j < feeds[i].length; ++j) {\n                _f.push(feeds[i][j]);\n            }\n            emit SetFeed(assets[i], feeds[i]);\n        }\n    }\n\n    function setSequencerOracle(address newSequencerOracle) external onlyOwner {\n        _setSequencerOracle(newSequencerOracle);\n    }\n\n    function _setSequencerOracle(address newSequencerOracle) internal {\n        sequencerOracle = newSequencerOracle;\n        emit SetSequencerOracle(newSequencerOracle);\n    }\n\n    function setTimeout(uint256 newTimeout) external onlyOwner {\n        _setTimeout(newTimeout);\n    }\n\n    function _setTimeout(uint256 newTimeout) internal {\n        if (newTimeout < _MIN_TIMEOUT || newTimeout > _MAX_TIMEOUT) revert InvalidTimeout();\n        timeout = newTimeout;\n        emit SetTimeout(newTimeout);\n    }\n\n    function setGracePeriod(uint256 newGracePeriod) external onlyOwner {\n        _setGracePeriod(newGracePeriod);\n    }\n\n    function _setGracePeriod(uint256 newGracePeriod) internal {\n        if (newGracePeriod < _MIN_GRACE_PERIOD || newGracePeriod > _MAX_GRACE_PERIOD) revert InvalidGracePeriod();\n        gracePeriod = newGracePeriod;\n        emit SetGracePeriod(newGracePeriod);\n    }\n\n    function _isSequencerValid() internal view returns (bool) {\n        // @dev When the chain is L1, sequencerOracle is not set and always returns true.\n        if (sequencerOracle == address(0)) {\n            return true;\n        }\n        (, int256 answer,, uint256 updatedAt,) = AggregatorV3Interface(sequencerOracle).latestRoundData();\n        return answer == 0 && block.timestamp - updatedAt > gracePeriod;\n    }\n}\n"
    },
    "src/oracle/DatastreamOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {Ownable, Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"../external/chainlink/ILogAutomation.sol\";\nimport {Common} from \"../external/chainlink/Common.sol\";\nimport {IFeeManager} from \"../external/chainlink/IFeeManager.sol\";\nimport {IRewardManager} from \"../external/chainlink/IRewardManager.sol\";\nimport {IVerifierFeeManager} from \"../external/chainlink/IVerifierFeeManager.sol\";\nimport {IVerifierProxy} from \"../external/chainlink/IVerifierProxy.sol\";\nimport {StreamsLookupCompatibleInterface} from \"../external/chainlink/StreamsLookupCompatibleInterface.sol\";\nimport {IDatastreamOracle} from \"../interfaces/IDatastreamOracle.sol\";\nimport {IOracle} from \"../interfaces/IOracle.sol\";\n\ncontract DatastreamOracle is\n    IDatastreamOracle,\n    Ownable2Step,\n    ILogAutomation,\n    StreamsLookupCompatibleInterface,\n    UUPSUpgradeable,\n    Initializable\n{\n    string public constant STRING_DATASTREAMS_FEEDLABEL = \"feedIDs\";\n    string public constant STRING_DATASTREAMS_QUERYLABEL = \"timestamp\";\n\n    IVerifierProxy public immutable verifier;\n    bytes32[] internal _feedIds;\n    mapping(bytes32 => FeedData) public _feedData;\n    mapping(address => uint256) internal _assetToPrice;\n    address public fallbackOracle;\n    address public forwarder;\n    mapping(address => bool) public isOperator;\n    uint256 public requestBitmap;\n\n    modifier onlyOperator() {\n        if (!isOperator[msg.sender]) revert NotOperator();\n        _;\n    }\n\n    constructor(address verifier_) Ownable(msg.sender) {\n        verifier = IVerifierProxy(verifier_);\n    }\n\n    function initialize(address owner_) external initializer {\n        _transferOwnership(owner_);\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n    function feeToken() public view returns (address) {\n        return IFeeManager(address(verifier.s_feeManager())).i_linkAddress();\n    }\n\n    function feeBalance() external view returns (uint256) {\n        return IERC20(feeToken()).balanceOf(address(this));\n    }\n\n    function feedData(bytes32 feedId) external view returns (FeedData memory) {\n        return _feedData[feedId];\n    }\n\n    function checkLog(Log calldata log, bytes memory) external view returns (bool, bytes memory) {\n        uint256 length = _feedIds.length;\n        string[] memory stringFeedIds = new string[](length);\n        uint256 bitmap = requestBitmap;\n        uint256 l = 0;\n        for (uint256 i = 0; i < length; ++i) {\n            if ((bitmap >> i) & 1 == 0) {\n                continue;\n            }\n            stringFeedIds[l] = Strings.toHexString(uint256(_feedIds[i]), 32);\n            ++l;\n        }\n        assembly {\n            mstore(stringFeedIds, l)\n        }\n        revert StreamsLookup(\n            STRING_DATASTREAMS_FEEDLABEL, stringFeedIds, STRING_DATASTREAMS_QUERYLABEL, log.timestamp, \"\"\n        );\n    }\n\n    /**\n     * @notice this is a new, optional function in streams lookup. It is meant to surface streams lookup errors.\n     * @return upkeepNeeded boolean to indicate whether the keeper should call performUpkeep or not.\n     * @return performData bytes that the keeper should call performUpkeep with, if\n     * upkeep is needed. If you would like to encode data to decode later, try `abi.encode`.\n     */\n    function checkErrorHandler(uint256, /*errCode*/ bytes memory /*extraData*/ )\n        external\n        pure\n        returns (bool, bytes memory)\n    {\n        return (true, \"0\");\n        // Hardcoded to always perform upkeep.\n        // Read the StreamsLookup error handler guide for more information.\n        // https://docs.chain.link/chainlink-automation/guides/streams-lookup-error-handler\n    }\n\n    // The Data Streams report bytes is passed here.\n    // extraData is context data from feed lookup process.\n    // Your contract may include logic to further process this data.\n    // This method is intended only to be simulated offchain by Automation.\n    // The data returned will then be passed by Automation into performUpkeep\n    function checkCallback(bytes[] calldata values, bytes calldata extraData)\n        external\n        pure\n        returns (bool, bytes memory)\n    {\n        return (true, abi.encode(values, extraData));\n    }\n\n    function performUpkeep(bytes calldata performData) external {\n        if (msg.sender != forwarder) revert InvalidForwarder();\n\n        // Decode the performData bytes passed in by CL Automation.\n        // This contains the data returned by your implementation in checkCallback().\n        (bytes[] memory signedReports,) = abi.decode(performData, (bytes[], bytes));\n\n        IFeeManager feeManager = IFeeManager(address(verifier.s_feeManager()));\n        IRewardManager rewardManager = IRewardManager(address(feeManager.i_rewardManager()));\n\n        address feeTokenAddress = feeManager.i_linkAddress();\n\n        for (uint256 i = 0; i < signedReports.length; ++i) {\n            bytes memory unverifiedReport = signedReports[i];\n\n            (, /* bytes32[3] reportContextData */ bytes memory reportData) =\n                abi.decode(unverifiedReport, (bytes32[3], bytes));\n\n            // Report verification fees\n            (Common.Asset memory fee,,) = feeManager.getFeeAndReward(address(this), reportData, feeTokenAddress);\n\n            // Approve rewardManager to spend this contract's balance in fees\n            if (fee.amount > 0) {\n                IERC20(feeTokenAddress).approve(address(rewardManager), fee.amount);\n            }\n\n            // Verify the report\n            bytes memory verifiedReportData = verifier.verify(unverifiedReport, abi.encode(feeTokenAddress));\n\n            // Decode verified report data into a Report struct\n            Report memory verifiedReport = abi.decode(verifiedReportData, (Report));\n\n            address asset = _feedData[verifiedReport.feedId].asset;\n            if (verifiedReport.price < 0) revert InvalidReport();\n            _assetToPrice[asset] = uint256(uint192(verifiedReport.price));\n\n            // Log price from report\n            emit SetPrice(asset, uint256(uint192(verifiedReport.price)));\n        }\n\n        // Reset rewardManager's approval to spend this contract's balance in fees\n        IERC20(feeTokenAddress).approve(address(rewardManager), 0);\n    }\n\n    function setFeed(bytes32 feedId, address asset) external onlyOwner {\n        FeedData memory data = _feedData[feedId];\n        data.asset = asset;\n        if (data.index == 0) {\n            data.index = uint96(_feedIds.length + 1);\n            _feedIds.push(feedId);\n        }\n        _feedData[feedId] = data;\n        emit SetFeed(data.asset, feedId, data.index);\n    }\n\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    function getAssetPrice(address asset) public view returns (uint256 price) {\n        price = _assetToPrice[asset];\n        if (price == 0) {\n            return IOracle(fallbackOracle).getAssetPrice(asset);\n        }\n    }\n\n    function getAssetsPrices(address[] memory assets) external view returns (uint256[] memory prices) {\n        prices = new uint256[](assets.length);\n        unchecked {\n            for (uint256 i = 0; i < assets.length; ++i) {\n                prices[i] = getAssetPrice(assets[i]);\n            }\n        }\n    }\n\n    function setForwarder(address newForwarder) external onlyOwner {\n        forwarder = newForwarder;\n        emit SetForwarder(newForwarder);\n    }\n\n    function setOperator(address operator, bool status) external onlyOwner {\n        isOperator[operator] = status;\n        emit SetOperator(operator, status);\n    }\n\n    function request(uint256 bitmap) external onlyOperator {\n        requestBitmap = bitmap;\n        emit Request(msg.sender, bitmap);\n    }\n\n    function getFeedIds() external view returns (bytes32[] memory) {\n        return _feedIds;\n    }\n\n    function getAllFeedData() external view returns (bytes32[] memory feedIds, FeedData[] memory data) {\n        feedIds = _feedIds;\n        uint256 length = feedIds.length;\n        data = new FeedData[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            data[i] = _feedData[feedIds[i]];\n        }\n    }\n\n    function setFallbackOracle(address newFallbackOracle) external onlyOwner {\n        fallbackOracle = newFallbackOracle;\n        emit SetFallbackOracle(newFallbackOracle);\n    }\n}\n"
    },
    "src/Rebalancer.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {Ownable2Step, Ownable} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {IERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IBookManager} from \"clober-dex/v2-core/interfaces/IBookManager.sol\";\nimport {ILocker} from \"clober-dex/v2-core/interfaces/ILocker.sol\";\nimport {BookId, BookIdLibrary} from \"clober-dex/v2-core/libraries/BookId.sol\";\nimport {Currency, CurrencyLibrary} from \"clober-dex/v2-core/libraries/Currency.sol\";\nimport {OrderId, OrderIdLibrary} from \"clober-dex/v2-core/libraries/OrderId.sol\";\nimport {Tick, TickLibrary} from \"clober-dex/v2-core/libraries/Tick.sol\";\nimport {FeePolicy, FeePolicyLibrary} from \"clober-dex/v2-core/libraries/FeePolicy.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {IRebalancer} from \"./interfaces/IRebalancer.sol\";\nimport {IStrategy} from \"./interfaces/IStrategy.sol\";\nimport {ERC6909Supply} from \"./libraries/ERC6909Supply.sol\";\n\ncontract Rebalancer is IRebalancer, ILocker, Ownable2Step, ERC6909Supply {\n    using BookIdLibrary for IBookManager.BookKey;\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using CurrencyLibrary for Currency;\n    using OrderIdLibrary for OrderId;\n    using TickLibrary for Tick;\n    using FeePolicyLibrary for FeePolicy;\n\n    uint256 public constant RATE_PRECISION = 1e6;\n\n    IBookManager public immutable bookManager;\n\n    mapping(bytes32 key => Pool) private _pools;\n    mapping(BookId => BookId) public bookPair;\n\n    modifier selfOnly() {\n        if (msg.sender != address(this)) revert NotSelf();\n        _;\n    }\n\n    constructor(IBookManager bookManager_, address initialOwner_) Ownable(initialOwner_) {\n        bookManager = bookManager_;\n    }\n\n    function decimals(uint256) external pure returns (uint8) {\n        return 18;\n    }\n\n    function getPool(bytes32 key) external view returns (Pool memory) {\n        return _pools[key];\n    }\n\n    function getBookPairs(bytes32 key) external view returns (BookId, BookId) {\n        return (_pools[key].bookIdA, _pools[key].bookIdB);\n    }\n\n    function getLiquidity(bytes32 key) public view returns (Liquidity memory liquidityA, Liquidity memory liquidityB) {\n        Pool storage pool = _pools[key];\n        liquidityA.reserve = pool.reserveA;\n        liquidityB.reserve = pool.reserveB;\n\n        OrderId[] memory orderListA = pool.orderListA;\n        OrderId[] memory orderListB = pool.orderListB;\n\n        if (orderListA.length > 0) {\n            IBookManager.BookKey memory bookKeyA = bookManager.getBookKey(pool.bookIdA);\n            for (uint256 i; i < orderListA.length; ++i) {\n                (uint256 cancelable, uint256 claimable) =\n                    _getLiquidity(bookKeyA.makerPolicy, bookKeyA.unitSize, orderListA[i]);\n                liquidityA.cancelable += cancelable;\n                liquidityB.claimable += claimable;\n            }\n        }\n        if (orderListB.length > 0) {\n            IBookManager.BookKey memory bookKeyB = bookManager.getBookKey(pool.bookIdB);\n            for (uint256 i; i < orderListB.length; ++i) {\n                (uint256 cancelable, uint256 claimable) =\n                    _getLiquidity(bookKeyB.makerPolicy, bookKeyB.unitSize, orderListB[i]);\n                liquidityA.claimable += claimable;\n                liquidityB.cancelable += cancelable;\n            }\n        }\n    }\n\n    function _getLiquidity(FeePolicy makerPolicy, uint64 unitSize, OrderId orderId)\n        internal\n        view\n        returns (uint256 cancelable, uint256 claimable)\n    {\n        IBookManager.OrderInfo memory orderInfo = bookManager.getOrder(orderId);\n        cancelable = uint256(orderInfo.open) * unitSize;\n        claimable = orderId.getTick().quoteToBase(uint256(orderInfo.claimable) * unitSize, false);\n        if (makerPolicy.usesQuote()) {\n            int256 fee = makerPolicy.calculateFee(cancelable, true);\n            cancelable = uint256(int256(cancelable) + fee);\n        } else {\n            int256 fee = makerPolicy.calculateFee(claimable, false);\n            claimable = uint256(int256(claimable) - fee);\n        }\n    }\n\n    function open(\n        IBookManager.BookKey calldata bookKeyA,\n        IBookManager.BookKey calldata bookKeyB,\n        bytes32 salt,\n        address strategy\n    ) external returns (bytes32) {\n        return abi.decode(\n            bookManager.lock(\n                address(this), abi.encodeWithSelector(this._open.selector, bookKeyA, bookKeyB, salt, strategy)\n            ),\n            (bytes32)\n        );\n    }\n\n    function mint(bytes32 key, uint256 amountA, uint256 amountB, uint256 minLpAmount)\n        external\n        payable\n        returns (uint256 mintAmount)\n    {\n        Pool storage pool = _pools[key];\n        IBookManager.BookKey memory bookKeyA = bookManager.getBookKey(pool.bookIdA);\n\n        uint256 supply = totalSupply[uint256(key)];\n        if (supply == 0) {\n            if (amountA == 0 || amountB == 0) revert InvalidAmount();\n            // @dev If the decimals > 18, it will revert.\n            uint256 complementA =\n                bookKeyA.quote.isNative() ? 1 : 10 ** (18 - IERC20Metadata(Currency.unwrap(bookKeyA.quote)).decimals());\n            uint256 complementB =\n                bookKeyA.base.isNative() ? 1 : 10 ** (18 - IERC20Metadata(Currency.unwrap(bookKeyA.base)).decimals());\n            uint256 _amountA = amountA * complementA;\n            uint256 _amountB = amountB * complementB;\n            mintAmount = _amountA > _amountB ? _amountA : _amountB;\n        } else {\n            (Liquidity memory liquidityA, Liquidity memory liquidityB) = getLiquidity(key);\n            uint256 totalLiquidityA = liquidityA.reserve + liquidityA.claimable + liquidityA.cancelable;\n            uint256 totalLiquidityB = liquidityB.reserve + liquidityB.claimable + liquidityB.cancelable;\n\n            if (totalLiquidityA == 0 && totalLiquidityB == 0) {\n                mintAmount = amountA = amountB = 0;\n            } else if (totalLiquidityA == 0) {\n                mintAmount = FixedPointMathLib.mulDivDown(amountB, supply, totalLiquidityB);\n                amountA = 0;\n            } else if (totalLiquidityB == 0) {\n                mintAmount = FixedPointMathLib.mulDivDown(amountA, supply, totalLiquidityA);\n                amountB = 0;\n            } else {\n                uint256 mintA = FixedPointMathLib.mulDivDown(amountA, supply, totalLiquidityA);\n                uint256 mintB = FixedPointMathLib.mulDivDown(amountB, supply, totalLiquidityB);\n                if (mintA > mintB) {\n                    mintAmount = mintB;\n                    amountA = FixedPointMathLib.mulDivUp(totalLiquidityA, mintAmount, supply);\n                } else {\n                    mintAmount = mintA;\n                    amountB = FixedPointMathLib.mulDivUp(totalLiquidityB, mintAmount, supply);\n                }\n            }\n        }\n        if (mintAmount < minLpAmount) revert Slippage();\n\n        uint256 refund = msg.value;\n        if (bookKeyA.quote.isNative()) {\n            if (msg.value < amountA) {\n                revert InvalidValue();\n            } else {\n                unchecked {\n                    refund -= amountA;\n                }\n            }\n        } else {\n            IERC20(Currency.unwrap(bookKeyA.quote)).safeTransferFrom(msg.sender, address(this), amountA);\n        }\n        if (bookKeyA.base.isNative()) {\n            if (msg.value < amountB) {\n                revert InvalidValue();\n            } else {\n                unchecked {\n                    refund -= amountB;\n                }\n            }\n        } else {\n            IERC20(Currency.unwrap(bookKeyA.base)).safeTransferFrom(msg.sender, address(this), amountB);\n        }\n\n        pool.reserveA += amountA;\n        pool.reserveB += amountB;\n\n        _mint(msg.sender, uint256(key), mintAmount);\n        pool.strategy.mintHook(msg.sender, key, mintAmount, supply);\n        emit Mint(msg.sender, key, amountA, amountB, mintAmount);\n\n        if (refund > 0) {\n            CurrencyLibrary.NATIVE.transfer(msg.sender, refund);\n        }\n    }\n\n    function burn(bytes32 key, uint256 amount, uint256 minAmountA, uint256 minAmountB)\n        external\n        returns (uint256 withdrawalA, uint256 withdrawalB)\n    {\n        (withdrawalA, withdrawalB) = abi.decode(\n            bookManager.lock(address(this), abi.encodeWithSelector(this._burn.selector, key, msg.sender, amount)),\n            (uint256, uint256)\n        );\n        if (withdrawalA < minAmountA || withdrawalB < minAmountB) revert Slippage();\n    }\n\n    function rebalance(bytes32 key) public {\n        bookManager.lock(address(this), abi.encodeWithSelector(this._rebalance.selector, key));\n    }\n\n    function lockAcquired(address lockCaller, bytes calldata data) external returns (bytes memory) {\n        if (msg.sender != address(bookManager)) revert InvalidLockAcquiredSender();\n        if (lockCaller != address(this)) revert InvalidLockCaller();\n\n        (bool success, bytes memory returnData) = address(this).call(data);\n        if (success) return returnData;\n        if (returnData.length == 0) revert LockFailure();\n        // if the call failed, bubble up the reason\n        /// @solidity memory-safe-assembly\n        assembly {\n            revert(add(returnData, 32), mload(returnData))\n        }\n    }\n\n    function _open(\n        IBookManager.BookKey calldata bookKeyA,\n        IBookManager.BookKey calldata bookKeyB,\n        bytes32 salt,\n        address strategy\n    ) public selfOnly returns (bytes32 key) {\n        if (\n            !(bookKeyA.quote.equals(bookKeyB.base) && bookKeyA.base.equals(bookKeyB.quote))\n                || bookKeyA.quote.equals(bookKeyA.base)\n        ) revert InvalidBookPair();\n        if (address(bookKeyA.hooks) != address(0) || address(bookKeyB.hooks) != address(0)) revert InvalidHook();\n        if (strategy == address(0)) revert InvalidStrategy();\n\n        BookId bookIdA = bookKeyA.toId();\n        BookId bookIdB = bookKeyB.toId();\n        if (!bookManager.isOpened(bookIdA)) bookManager.open(bookKeyA, \"\");\n        if (!bookManager.isOpened(bookIdB)) bookManager.open(bookKeyB, \"\");\n\n        key = _encodeKey(bookIdA, bookIdB, salt);\n        if (_pools[key].strategy != IStrategy(address(0))) revert AlreadyOpened();\n\n        _pools[key].bookIdA = bookIdA;\n        _pools[key].bookIdB = bookIdB;\n        _pools[key].strategy = IStrategy(strategy);\n        bookPair[bookIdA] = bookIdB;\n        bookPair[bookIdB] = bookIdA;\n\n        emit Open(key, bookIdA, bookIdB, salt, strategy);\n    }\n\n    function _burn(bytes32 key, address user, uint256 burnAmount)\n        public\n        selfOnly\n        returns (uint256 withdrawalA, uint256 withdrawalB)\n    {\n        Pool storage pool = _pools[key];\n        uint256 supply = totalSupply[uint256(key)];\n\n        (uint256 canceledAmountA, uint256 canceledAmountB, uint256 claimedAmountA, uint256 claimedAmountB) =\n            _clearPool(key, pool, burnAmount, supply);\n\n        uint256 reserveA = pool.reserveA;\n        uint256 reserveB = pool.reserveB;\n\n        withdrawalA = (reserveA + claimedAmountA) * burnAmount / supply + canceledAmountA;\n        withdrawalB = (reserveB + claimedAmountB) * burnAmount / supply + canceledAmountB;\n\n        _burn(user, uint256(key), burnAmount);\n        pool.strategy.burnHook(msg.sender, key, burnAmount, supply);\n        emit Burn(user, key, withdrawalA, withdrawalB, burnAmount);\n\n        IBookManager.BookKey memory bookKeyA = bookManager.getBookKey(pool.bookIdA);\n\n        pool.reserveA = _settleCurrency(bookKeyA.quote, reserveA) - withdrawalA;\n        pool.reserveB = _settleCurrency(bookKeyA.base, reserveB) - withdrawalB;\n\n        if (withdrawalA > 0) {\n            bookKeyA.quote.transfer(user, withdrawalA);\n        }\n        if (withdrawalB > 0) {\n            bookKeyA.base.transfer(user, withdrawalB);\n        }\n    }\n\n    function _rebalance(bytes32 key) public selfOnly {\n        Pool storage pool = _pools[key];\n        uint256 reserveA = pool.reserveA;\n        uint256 reserveB = pool.reserveB;\n        IBookManager.BookKey memory bookKeyA = bookManager.getBookKey(pool.bookIdA);\n        IBookManager.BookKey memory bookKeyB = bookManager.getBookKey(pool.bookIdB);\n\n        // Compute allocation\n        try pool.strategy.computeOrders(key) returns (\n            IStrategy.Order[] memory liquidityA, IStrategy.Order[] memory liquidityB\n        ) {\n            if (liquidityA.length == 0 && liquidityB.length == 0) return;\n            _clearPool(key, pool, 1, 1);\n\n            _setLiquidity(bookKeyA, liquidityA, pool.orderListA);\n            _setLiquidity(bookKeyB, liquidityB, pool.orderListB);\n\n            pool.strategy.rebalanceHook(msg.sender, key, liquidityA, liquidityB);\n            emit Rebalance(key);\n        } catch {\n            _clearPool(key, pool, 1, 1);\n        }\n\n        pool.reserveA = _settleCurrency(bookKeyA.quote, reserveA);\n        pool.reserveB = _settleCurrency(bookKeyA.base, reserveB);\n    }\n\n    function _clearPool(bytes32 key, Pool storage pool, uint256 cancelNumerator, uint256 cancelDenominator)\n        internal\n        returns (uint256 canceledAmountA, uint256 canceledAmountB, uint256 claimedAmountA, uint256 claimedAmountB)\n    {\n        (canceledAmountA, claimedAmountB) = _clearOrders(pool.orderListA, cancelNumerator, cancelDenominator);\n        (canceledAmountB, claimedAmountA) = _clearOrders(pool.orderListB, cancelNumerator, cancelDenominator);\n        emit Claim(key, claimedAmountA, claimedAmountB);\n        emit Cancel(key, canceledAmountA, canceledAmountB);\n    }\n\n    function _clearOrders(OrderId[] storage orderIds, uint256 cancelNumerator, uint256 cancelDenominator)\n        internal\n        returns (uint256 canceledAmount, uint256 claimedAmount)\n    {\n        OrderId[] memory mOrderIds = orderIds;\n        for (uint256 i = 0; i < mOrderIds.length; ++i) {\n            OrderId orderId = mOrderIds[i];\n            IBookManager.OrderInfo memory orderInfo = bookManager.getOrder(orderId);\n            if (orderInfo.claimable > 0) {\n                claimedAmount += bookManager.claim(orderId, \"\");\n            }\n            if (orderInfo.open > 0) {\n                canceledAmount += bookManager.cancel(\n                    IBookManager.CancelParams({\n                        id: orderId,\n                        toUnit: (orderInfo.open - orderInfo.open * cancelNumerator / cancelDenominator).toUint64()\n                    }),\n                    \"\"\n                );\n            }\n        }\n        if (cancelDenominator == cancelNumerator) {\n            assembly {\n                sstore(orderIds.slot, 0)\n            }\n        }\n    }\n\n    function _setLiquidity(\n        IBookManager.BookKey memory bookKey,\n        IStrategy.Order[] memory liquidity,\n        OrderId[] storage emptyOrderIds\n    ) internal {\n        for (uint256 i = 0; i < liquidity.length; ++i) {\n            if (liquidity[i].rawAmount == 0) continue;\n            (OrderId orderId,) = bookManager.make(\n                IBookManager.MakeParams({\n                    key: bookKey,\n                    tick: liquidity[i].tick,\n                    unit: liquidity[i].rawAmount,\n                    provider: address(0)\n                }),\n                \"\"\n            );\n            emptyOrderIds.push(orderId);\n        }\n    }\n\n    function _settleCurrency(Currency currency, uint256 liquidity) internal returns (uint256) {\n        bookManager.settle(currency);\n\n        int256 delta = bookManager.getCurrencyDelta(address(this), currency);\n        if (delta > 0) {\n            bookManager.withdraw(currency, address(this), uint256(delta));\n            liquidity += uint256(delta);\n        } else if (delta < 0) {\n            currency.transfer(address(bookManager), uint256(-delta));\n            bookManager.settle(currency);\n            liquidity -= uint256(-delta);\n        }\n        return liquidity;\n    }\n\n    function _encodeKey(BookId bookIdA, BookId bookIdB, bytes32 salt) internal pure returns (bytes32) {\n        if (BookId.unwrap(bookIdA) > BookId.unwrap(bookIdB)) (bookIdA, bookIdB) = (bookIdB, bookIdA);\n        return keccak256(abi.encodePacked(bookIdA, bookIdB, salt));\n    }\n\n    receive() external payable {}\n}\n"
    },
    "src/SimpleOracleStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {Ownable, Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {Tick, TickLibrary} from \"clober-dex/v2-core/libraries/Tick.sol\";\nimport {IBookManager} from \"clober-dex/v2-core/interfaces/IBookManager.sol\";\nimport {FeePolicy, FeePolicyLibrary} from \"clober-dex/v2-core/libraries/FeePolicy.sol\";\nimport {BookId} from \"clober-dex/v2-core/libraries/BookId.sol\";\nimport {Currency, CurrencyLibrary} from \"clober-dex/v2-core/libraries/Currency.sol\";\n\nimport {IStrategy} from \"./interfaces/IStrategy.sol\";\nimport {IOracle} from \"./interfaces/IOracle.sol\";\nimport {ISimpleOracleStrategy} from \"./interfaces/ISimpleOracleStrategy.sol\";\nimport {IRebalancer} from \"./interfaces/IRebalancer.sol\";\n\ncontract SimpleOracleStrategy is ISimpleOracleStrategy, Ownable2Step {\n    using CurrencyLibrary for Currency;\n    using FeePolicyLibrary for FeePolicy;\n    using TickLibrary for Tick;\n\n    uint256 public constant RATE_PRECISION = 1e6;\n    uint256 public constant LAST_RAW_AMOUNT_MASK = (1 << 128) - 1;\n\n    IOracle public immutable referenceOracle;\n    IRebalancer public immutable rebalancer;\n    IBookManager public immutable bookManager;\n\n    mapping(address => bool) public isOperator;\n    mapping(bytes32 => Config) internal _configs;\n    mapping(bytes32 => Position) internal _positions;\n    mapping(bytes32 => uint256) internal _lastRawAmounts;\n\n    modifier onlyOperator() {\n        if (!isOperator[msg.sender]) revert NotOperator();\n        _;\n    }\n\n    constructor(IOracle referenceOracle_, IRebalancer rebalancer_, IBookManager bookManager_, address initialOwner)\n        Ownable(initialOwner)\n    {\n        referenceOracle = referenceOracle_;\n        rebalancer = rebalancer_;\n        bookManager = bookManager_;\n    }\n\n    function getConfig(bytes32 key) external view returns (Config memory) {\n        return _configs[key];\n    }\n\n    function getPosition(bytes32 key) external view returns (Position memory) {\n        return _positions[key];\n    }\n\n    function getLastRawAmount(bytes32 key) external view returns (uint256, uint256) {\n        uint256 lastRawAmounts = _lastRawAmounts[key];\n        return (lastRawAmounts >> 128, lastRawAmounts & LAST_RAW_AMOUNT_MASK);\n    }\n\n    function computeOrders(bytes32 key) external view returns (Order[] memory ordersA, Order[] memory ordersB) {\n        Position memory position = _positions[key];\n        if (position.paused) revert Paused();\n\n        Config memory config = _configs[key];\n\n        IBookManager.BookKey memory bookKeyA;\n        IBookManager.BookKey memory bookKeyB;\n        IRebalancer.Liquidity memory liquidityA;\n        IRebalancer.Liquidity memory liquidityB;\n        {\n            (BookId bookIdA, BookId bookIdB) = rebalancer.getBookPairs(key);\n            bookKeyA = bookManager.getBookKey(bookIdA);\n            bookKeyB = bookManager.getBookKey(bookIdB);\n\n            (liquidityA, liquidityB) = rebalancer.getLiquidity(key);\n\n            uint256 lastRawAmounts = _lastRawAmounts[key];\n            if (\n                lastRawAmounts > 0\n                    && (\n                        liquidityA.cancelable\n                            > (lastRawAmounts >> 128) * bookKeyA.unitSize * config.rebalanceThreshold / RATE_PRECISION\n                            || liquidityB.cancelable\n                                > (lastRawAmounts & LAST_RAW_AMOUNT_MASK) * bookKeyB.unitSize * config.rebalanceThreshold\n                                    / RATE_PRECISION\n                    )\n            ) {\n                return (ordersA, ordersB);\n            }\n\n            if (!_isOraclePriceValid(position.oraclePrice, config.referenceThreshold, bookKeyA.quote, bookKeyA.base)) {\n                revert InvalidOraclePrice();\n            }\n        }\n\n        (uint256 amountA, uint256 amountB) = _calculateAmounts(\n            liquidityA.reserve + liquidityA.cancelable + liquidityA.claimable,\n            liquidityB.reserve + liquidityB.cancelable + liquidityB.claimable,\n            position.oraclePrice,\n            _getCurrencyDecimals(bookKeyA.quote),\n            _getCurrencyDecimals(bookKeyA.base),\n            config\n        );\n\n        if (bookKeyA.makerPolicy.usesQuote()) amountA = bookKeyA.makerPolicy.calculateOriginalAmount(amountA, false);\n        if (bookKeyB.makerPolicy.usesQuote()) amountB = bookKeyB.makerPolicy.calculateOriginalAmount(amountB, false);\n\n        // SimpleStrategy has only one bid and one ask order\n        ordersA = new Order[](1);\n        ordersB = new Order[](1);\n        ordersA[0] = Order({\n            tick: position.tickA,\n            rawAmount: SafeCast.toUint64(amountA * position.rate / bookKeyA.unitSize / RATE_PRECISION)\n        });\n        ordersB[0] = Order({\n            tick: position.tickB,\n            rawAmount: SafeCast.toUint64(amountB * position.rate / bookKeyB.unitSize / RATE_PRECISION)\n        });\n\n        return (ordersA, ordersB);\n    }\n\n    function _calculateAmounts(\n        uint256 amountA,\n        uint256 amountB,\n        uint256 oraclePrice,\n        uint8 decimalsA,\n        uint8 decimalsB,\n        Config memory config\n    ) internal view returns (uint256 resultA, uint256 resultB) {\n        // @dev Use the same decimals for both amounts to calculate the value properly\n        if (decimalsA > decimalsB) {\n            amountB = amountB * 10 ** (decimalsA - decimalsB);\n        } else if (decimalsA < decimalsB) {\n            amountA = amountA * 10 ** (decimalsB - decimalsA);\n        }\n\n        resultA = amountA * config.rateA / RATE_PRECISION;\n        resultB = amountB * config.rateB / RATE_PRECISION;\n\n        uint256 basePrice = 10 ** referenceOracle.decimals();\n        uint256 valueA = resultA * basePrice;\n        uint256 valueB = resultB * oraclePrice;\n\n        if (valueA > valueB) {\n            resultA = valueB / basePrice;\n            valueA = resultA * basePrice;\n        } else {\n            resultB = valueA / oraclePrice;\n            valueB = resultB * oraclePrice;\n        }\n\n        if (valueA < amountA * config.minRateA / RATE_PRECISION * basePrice) {\n            resultA = amountA * config.minRateA / RATE_PRECISION;\n        }\n        if (valueB < amountB * config.minRateB / RATE_PRECISION * oraclePrice) {\n            resultB = amountB * config.minRateB / RATE_PRECISION;\n        }\n\n        // @dev Turn back to original decimals\n        if (decimalsA > decimalsB) {\n            resultB = resultB / 10 ** (decimalsA - decimalsB);\n        } else if (decimalsA < decimalsB) {\n            resultA = resultA / 10 ** (decimalsB - decimalsA);\n        }\n    }\n\n    function isOraclePriceValid(bytes32 key) external view returns (bool) {\n        Config memory config = _configs[key];\n        Position memory position = _positions[key];\n\n        (BookId bookIdA,) = rebalancer.getBookPairs(key);\n\n        IBookManager.BookKey memory bookKeyA = bookManager.getBookKey(bookIdA);\n\n        return _isOraclePriceValid(position.oraclePrice, config.referenceThreshold, bookKeyA.quote, bookKeyA.base);\n    }\n\n    function _isOraclePriceValid(\n        uint256 oraclePrice,\n        uint256 referenceThreshold,\n        Currency currencyA,\n        Currency currencyB\n    ) internal view returns (bool) {\n        uint256 referencePrice;\n        address[] memory assets = new address[](2);\n        assets[0] = Currency.unwrap(currencyA);\n        assets[1] = Currency.unwrap(currencyB);\n\n        try referenceOracle.getAssetsPrices(assets) returns (uint256[] memory prices) {\n            // price = basePrice / quotePrice\n            referencePrice = prices[1] * 10 ** referenceOracle.decimals() / prices[0];\n        } catch {\n            return false;\n        }\n\n        if (\n            referencePrice * (RATE_PRECISION + referenceThreshold) / RATE_PRECISION < oraclePrice\n                || referencePrice * (RATE_PRECISION - referenceThreshold) / RATE_PRECISION > oraclePrice\n        ) {\n            return false;\n        }\n        return true;\n    }\n\n    function isPaused(bytes32 key) external view returns (bool) {\n        return _positions[key].paused;\n    }\n\n    function pause(bytes32 key) external onlyOperator {\n        delete _lastRawAmounts[key];\n        _positions[key].paused = true;\n        emit Pause(key);\n    }\n\n    function unpause(bytes32 key) external onlyOperator {\n        _positions[key].paused = false;\n        emit Unpause(key);\n    }\n\n    function updatePosition(bytes32 key, uint256 oraclePrice, Tick tickA, Tick tickB, uint24 rate)\n        external\n        onlyOperator\n    {\n        uint256 priceA = tickA.toPrice();\n        uint256 priceB = Tick.wrap(-Tick.unwrap(tickB)).toPrice();\n\n        (BookId bookIdA, BookId bookIdB) = rebalancer.getBookPairs(key);\n        IBookManager.BookKey memory bookKeyA = bookManager.getBookKey(bookIdA);\n\n        uint256 priceWithFee = uint256(int256(priceA) - bookKeyA.makerPolicy.calculateFee(priceA, false));\n        priceWithFee = uint256(\n            int256(priceWithFee) - bookManager.getBookKey(bookIdB).makerPolicy.calculateFee(priceWithFee, false)\n        );\n\n        if (priceWithFee >= priceB) revert InvalidPrice();\n        if (rate > RATE_PRECISION) revert InvalidValue();\n\n        Config memory config = _configs[key];\n        if (\n            oraclePrice * (RATE_PRECISION + config.priceThresholdA) / RATE_PRECISION < priceA\n                || oraclePrice * (RATE_PRECISION - config.priceThresholdB) / RATE_PRECISION > priceB\n        ) revert ExceedsThreshold();\n\n        // @dev Convert oracle price to the same decimals as the reference oracle\n        oraclePrice =\n            oraclePrice * 10 ** _getCurrencyDecimals(bookKeyA.base) / 10 ** _getCurrencyDecimals(bookKeyA.quote);\n        oraclePrice = (oraclePrice * 10 ** referenceOracle.decimals()) >> 96;\n        if (!_isOraclePriceValid(oraclePrice, config.referenceThreshold, bookKeyA.quote, bookKeyA.base)) {\n            revert InvalidOraclePrice();\n        }\n\n        Position memory position = _positions[key];\n        position.oraclePrice = SafeCast.toUint128(oraclePrice);\n        position.tickA = tickA;\n        position.tickB = tickB;\n        position.rate = rate;\n\n        _positions[key] = position;\n        delete _lastRawAmounts[key];\n        emit UpdatePosition(key, oraclePrice, tickA, tickB, rate);\n    }\n\n    function setConfig(bytes32 key, Config memory config) external onlyOwner {\n        if (\n            config.referenceThreshold > RATE_PRECISION || config.rebalanceThreshold > RATE_PRECISION\n                || config.rateA > RATE_PRECISION || config.rateB > RATE_PRECISION || config.minRateA > RATE_PRECISION\n                || config.minRateB > RATE_PRECISION || config.priceThresholdA > RATE_PRECISION\n                || config.priceThresholdB > RATE_PRECISION\n        ) revert InvalidConfig();\n\n        if (config.rateA < config.minRateA || config.rateB < config.minRateB) revert InvalidConfig();\n\n        _configs[key] = config;\n        emit UpdateConfig(key, config);\n    }\n\n    function setOperator(address operator, bool status) external onlyOwner {\n        isOperator[operator] = status;\n        emit SetOperator(operator, status);\n    }\n\n    function _getCurrencyDecimals(Currency currency) internal view returns (uint8) {\n        return currency.isNative() ? 18 : IERC20Metadata(Currency.unwrap(currency)).decimals();\n    }\n\n    function mintHook(address, bytes32, uint256, uint256) external view {\n        if (msg.sender != address(rebalancer)) revert InvalidAccess();\n    }\n\n    function burnHook(address, bytes32 key, uint256 burnAmount, uint256 lastTotalSupply) external {\n        if (msg.sender != address(rebalancer)) revert InvalidAccess();\n        uint256 lastRawAmounts = _lastRawAmounts[key];\n        _lastRawAmounts[key] = lastRawAmounts - (((lastRawAmounts >> 128) * burnAmount / lastTotalSupply) << 128)\n            - (lastRawAmounts & LAST_RAW_AMOUNT_MASK) * burnAmount / lastTotalSupply;\n    }\n\n    function rebalanceHook(address, bytes32 key, Order[] memory liquidityA, Order[] memory liquidityB) external {\n        if (msg.sender != address(rebalancer)) revert InvalidAccess();\n        uint256 lastRawAmountA;\n        uint256 lastRawAmountB;\n        for (uint256 i = 0; i < liquidityA.length; ++i) {\n            IStrategy.Order memory order = liquidityA[i];\n            lastRawAmountA += order.rawAmount;\n        }\n\n        for (uint256 i = 0; i < liquidityB.length; ++i) {\n            IStrategy.Order memory order = liquidityB[i];\n            lastRawAmountB += order.rawAmount;\n        }\n        _lastRawAmounts[key] = (lastRawAmountA << 128) + lastRawAmountB;\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "cancun",
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}